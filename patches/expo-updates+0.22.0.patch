diff --git a/node_modules/expo-updates/android/src/main/java/expo/modules/updates/launcher/DatabaseLauncher.kt b/node_modules/expo-updates/android/src/main/java/expo/modules/updates/launcher/DatabaseLauncher.kt
index c37312a..1cc5bf2 100644
--- a/node_modules/expo-updates/android/src/main/java/expo/modules/updates/launcher/DatabaseLauncher.kt
+++ b/node_modules/expo-updates/android/src/main/java/expo/modules/updates/launcher/DatabaseLauncher.kt
@@ -100,7 +100,7 @@ class DatabaseLauncher(
 
     val assetEntities = database.assetDao().loadAssetsForUpdate(launchedUpdate!!.id)
 
-    localAssetFiles = mutableMapOf<AssetEntity, String>().apply {
+    localAssetFiles = embeddedAssetFileMap(context).apply {
       for (asset in assetEntities) {
         if (asset.id == launchAsset.id) {
           // we took care of this one above
@@ -149,8 +149,28 @@ class DatabaseLauncher(
     return database.updateDao().loadAllUpdateIdsWithStatus(UpdateStatus.READY)
   }
 
-  internal fun ensureAssetExists(asset: AssetEntity, database: UpdatesDatabase, context: Context): File? {
-    val assetFile = File(updatesDirectory, asset.relativePath)
+  private fun embeddedAssetFileMap(context: Context): MutableMap<AssetEntity, String> {
+    val embeddedManifest = EmbeddedManifest.get(context, this.configuration)
+    val embeddedAssets: List<AssetEntity> = embeddedManifest?.assetEntityList ?: listOf()
+    return mutableMapOf<AssetEntity, String>().apply {
+      for (asset in embeddedAssets) {
+        if (asset.isLaunchAsset) {
+          continue
+        }
+        val filename = asset.relativePath
+        if (filename != null) {
+          val file = when (asset.embeddedAssetFilename != null) {
+            true -> File(asset.embeddedAssetFilename)
+            false -> File(updatesDirectory, asset.relativePath)
+          }
+          this[asset] = Uri.fromFile(file).toString()
+        }
+      }
+    }
+  }
+
+  private fun ensureAssetExists(asset: AssetEntity, database: UpdatesDatabase, context: Context): File? {
+    val assetFile = File(updatesDirectory, asset.relativePath ?: "")
     var assetFileExists = assetFile.exists()
     if (!assetFileExists) {
       // something has gone wrong, we're missing this asset
@@ -199,7 +219,7 @@ class DatabaseLauncher(
 
           override fun onSuccess(assetEntity: AssetEntity, isNew: Boolean) {
             database.assetDao().updateAsset(assetEntity)
-            val assetFileLocal = File(updatesDirectory, assetEntity.relativePath)
+            val assetFileLocal = File(updatesDirectory, assetEntity.relativePath ?: "")
             maybeFinish(assetEntity, if (assetFileLocal.exists()) assetFileLocal else null)
           }
         }
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppController.swift b/node_modules/expo-updates/ios/EXUpdates/AppController.swift
index af48b0a..e581302 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppController.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppController.swift
@@ -1,67 +1,23 @@
 //  Copyright © 2019 650 Industries. All rights reserved.
 
 // swiftlint:disable line_length
-
-// this class used a bunch of implicit non-null patterns for member variables. not worth refactoring to appease lint.
+// swiftlint:disable type_body_length
+// swiftlint:disable closure_body_length
 // swiftlint:disable force_unwrapping
 
 import Foundation
-import SwiftUI
-
-@objc(EXUpdatesAppControllerDelegate)
-public protocol AppControllerDelegate: AnyObject {
-  func appController(_ appController: AppController, didStartWithSuccess success: Bool)
-}
-
-/**
- * Main entry point to expo-updates in normal release builds (development clients, including Expo
- * Go, use a different entry point). Singleton that keeps track of updates state, holds references
- * to instances of other updates classes, and is the central hub for all updates-related tasks.
- *
- * The `start` method in this class should be invoked early in the application lifecycle, via
- * ExpoUpdatesReactDelegateHandler. It delegates to an instance of AppLoaderTask to start
- * the process of loading and launching an update, then responds appropriately depending on the
- * callbacks that are invoked.
- *
- * This class also provides getter methods to access information about the updates state, which are
- * used by the exported UpdatesModule through EXUpdatesService. Such information includes
- * references to: the database, the UpdatesConfig object, the path on disk to the updates
- * directory, any currently active AppLoaderTask, the current SelectionPolicy, the
- * error recovery handler, and the current launched update. This class is intended to be the source
- * of truth for these objects, so other classes shouldn't retain any of them indefinitely.
- */
-@objc(EXUpdatesAppController)
-@objcMembers
-public class AppController: NSObject, AppLoaderTaskDelegate, AppLoaderTaskSwiftDelegate, ErrorRecoveryDelegate, UpdatesStateChangeDelegate {
-  private static let ErrorDomain = "EXUpdatesAppController"
-  private static let EXUpdatesEventName = "Expo.nativeUpdatesEvent"
-  private static let EXUpdatesStateChangeEventName = "Expo.nativeUpdatesStateChangeEvent"
-
-  // Events for the legacy UpdateEvent JS listener
-  public static let UpdateAvailableEventName = "updateAvailable"
-  public static let NoUpdateAvailableEventName = "noUpdateAvailable"
-  public static let ErrorEventName = "error"
-
-  /**
-   Delegate which will be notified when EXUpdates has an update ready to launch and
-   `launchAssetUrl` is nonnull.
-   */
-  public weak var delegate: AppControllerDelegate?
-
-  /**
-   The RCTBridge for which EXUpdates is providing the JS bundle and assets.
-   This is optional, but required in order for `Updates.reload()` and Updates module events to work.
-   */
-  public weak var bridge: RCTBridge?
-
-  /**
-   The URL on disk to source asset for the RCTBridge.
-   Will be null until the AppController delegate method is called.
-   This should be provided in the `sourceURLForBridge:` method of RCTBridgeDelegate.
-   */
-  public func launchAssetUrl() -> URL? {
-    return launcher?.launchAssetUrl
-  }
+import ExpoModulesCore
+
+public struct UpdatesModuleConstants {
+  let launchedUpdate: Update?
+  let embeddedUpdate: Update?
+  let isEmergencyLaunch: Bool
+  let isEnabled: Bool
+  let releaseChannel: String
+  let isUsingEmbeddedAssets: Bool
+  let runtimeVersion: String?
+  let checkOnLaunch: CheckAutomaticallyConfig
+  let requestHeaders: [String: String]
 
   /**
    A dictionary of the locally downloaded assets for the current update. Keys are the remote URLs
@@ -69,138 +25,40 @@ public class AppController: NSObject, AppLoaderTaskDelegate, AppLoaderTaskSwiftD
    can be used by `expo-asset` or a similar module to override React Native's asset resolution and
    use the locally downloaded assets.
    */
-  public func assetFilesMap() -> [String: Any]? {
-    return launcher?.assetFilesMap
-  }
-
-  public func isUsingEmbeddedAssets() -> Bool {
-    guard let launcher = launcher else {
-      return true
-    }
-    return launcher.isUsingEmbeddedAssets()
-  }
-
-  /**
-   for internal use in EXUpdates
-   */
-  public var config: UpdatesConfig
-  internal var launcher: AppLauncher?
-  public let database: UpdatesDatabase
-  internal var defaultSelectionPolicy: SelectionPolicy
-  private let errorRecovery: ErrorRecovery
-  public internal(set) var updatesDirectory: URL?
-  internal let controllerQueue: DispatchQueue
-  internal let assetFilesQueue: DispatchQueue
-  public internal(set) var isStarted: Bool
-
-  private var eventsToSendToJS: [[String: Any?]] = []
-
-  internal var stateMachine: UpdatesStateMachine?
-
-  private var loaderTask: AppLoaderTask?
-  private var candidateLauncher: AppLauncher?
-
-  public internal(set) var isEmergencyLaunch: Bool
-
-  private var _selectionPolicy: SelectionPolicy?
-
-  public var remoteLoadStatus: RemoteLoadStatus
-
-  internal let logger: UpdatesLogger
+  let assetFilesMap: [String: Any]?
 
-  public static let sharedInstance = AppController()
-
-  override init() {
-    var configInit: UpdatesConfig?
-    do {
-      configInit = try UpdatesConfig.configWithExpoPlist(mergingOtherDictionary: nil)
-    } catch {
-      NSException(
-        name: .internalInconsistencyException,
-        reason: "Cannot load configuration from Expo.plist. Please ensure you've followed the setup and installation instructions for expo-updates to create Expo.plist and add it to your Xcode project."
-      )
-      .raise()
-    }
-    self.config = configInit!
-    self.database = UpdatesDatabase()
-    self.defaultSelectionPolicy = SelectionPolicyFactory.filterAwarePolicy(
-      withRuntimeVersion: UpdatesUtils.getRuntimeVersion(withConfig: self.config)
-    )
-    self.errorRecovery = ErrorRecovery()
-    self.assetFilesQueue = DispatchQueue(label: "expo.controller.AssetFilesQueue")
-    self.controllerQueue = DispatchQueue(label: "expo.controller.ControllerQueue")
-    self.isStarted = false
-    self.remoteLoadStatus = .Idle
-    self.isEmergencyLaunch = false
-    self.logger = UpdatesLogger()
-    self.logger.info(message: "AppController sharedInstance created")
-
-    super.init()
+  let isMissingRuntimeVersion: Bool
+}
 
-    self.errorRecovery.delegate = self
-    self.stateMachine = UpdatesStateMachine(changeEventDelegate: self)
-    self.stateMachine?.reset()
-  }
+public enum FetchUpdateResult {
+  case success(manifest: [String: Any])
+  case failure
+  case rollBackToEmbedded
+  case error(error: Error)
+}
 
+@objc(EXUpdatesAppControllerInterface)
+public protocol AppControllerInterface {
   /**
-   Overrides the configuration values specified in Expo.plist with the ones provided in this
-   dictionary. This method can be used if any of these values should be determined at runtime
-   instead of buildtime. If used, this method must be called before any other method on the
-   shared instance of AppController.
+   The RCTBridge for which EXUpdates is providing the JS bundle and assets.
+   This is optional, but required in order for `Updates.reload()` and Updates module events to work.
    */
-  public func setConfiguration(_ configuration: [String: Any]) {
-    if isStarted {
-      NSException(
-        name: .internalInconsistencyException,
-        reason: "AppController:setConfiguration should not be called after start"
-      )
-      .raise()
-    }
-
-    do {
-      config = try UpdatesConfig.configWithExpoPlist(mergingOtherDictionary: configuration)
-    } catch {
-      NSException(
-        name: .internalInconsistencyException,
-        reason: "Cannot load configuration from Expo.plist or merged dictionary. Please ensure you've followed the setup and installation instructions for expo-updates to create Expo.plist and add it to your Xcode project."
-      )
-      .raise()
-    }
-
-    defaultSelectionPolicy = SelectionPolicyFactory.filterAwarePolicy(
-      withRuntimeVersion: UpdatesUtils.getRuntimeVersion(withConfig: config)
-    )
-
-    resetSelectionPolicyToDefault()
-  }
-
-  public func selectionPolicy() -> SelectionPolicy {
-    if _selectionPolicy == nil {
-      _selectionPolicy = defaultSelectionPolicy
-    }
-    return _selectionPolicy!
-  }
+  @objc weak var bridge: AnyObject? { get set }
 
   /**
-   * For external modules that want to modify the selection policy used at runtime.
-   *
-   * This method does not provide any guarantees about how long the provided selection policy will
-   * persist; sometimes expo-updates will reset the selection policy in situations where it makes
-   * sense to have explicit control (e.g. if the developer/user has programmatically fetched an
-   * update, expo-updates will reset the selection policy so the new update is launched on the
-   * next reload).
+   Delegate which will be notified when EXUpdates has an update ready to launch and
+   `launchAssetUrl` is nonnull.
    */
-  public func setNextSelectionPolicy(_ nextSelectionPolicy: SelectionPolicy) {
-    _selectionPolicy = nextSelectionPolicy
-  }
+  @objc weak var delegate: AppControllerDelegate? { get set }
 
   /**
-   * Similar to the above method, but sets the next selection policy to whatever
-   * AppController's default selection policy is.
+   The URL on disk to source asset for the RCTBridge.
+   Will be null until the AppController delegate method is called.
+   This should be provided in the `sourceURLForBridge:` method of RCTBridgeDelegate.
    */
-  public func resetSelectionPolicyToDefault() {
-    _selectionPolicy = nil
-  }
+  @objc func launchAssetUrl() -> URL?
+
+  @objc var isStarted: Bool { get }
 
   /**
    Starts the update process to launch a previously-loaded update and (if configured to do so)
@@ -211,300 +69,140 @@ public class AppController: NSObject, AppLoaderTaskDelegate, AppLoaderTaskSwiftD
    to load. If your splash screen setup is simple, you may want to use the
    `startAndShowLaunchScreen:` method instead.
    */
-  public func start() {
-    precondition(!isStarted, "AppController:start should only be called once per instance")
-
-    if !config.isEnabled {
-      let launcherNoDatabase = AppLauncherNoDatabase()
-      launcher = launcherNoDatabase
-      launcherNoDatabase.launchUpdate(withConfig: config)
-
-      delegate.let { _ in
-        DispatchQueue.main.async { [weak self] in
-          if let strongSelf = self {
-            strongSelf.delegate?.appController(strongSelf, didStartWithSuccess: strongSelf.launchAssetUrl() != nil)
-            strongSelf.sendQueuedEventsToBridge()
-          }
-        }
-      }
-
-      return
-    }
-
-    if config.updateUrl == nil {
-      NSException(
-        name: .internalInconsistencyException,
-        reason: "expo-updates is enabled, but no valid URL is configured under EXUpdatesURL. If you are making a release build for the first time, make sure you have run `expo publish` at least once."
-      )
-      .raise()
-    }
-
-    if config.scopeKey == nil {
-      NSException(
-        name: .internalInconsistencyException,
-        reason: "expo-updates was configured with no scope key. Make sure a valid URL is configured under EXUpdatesURL."
-      )
-      .raise()
-    }
-
-    isStarted = true
-
-    purgeUpdatesLogsOlderThanOneDay()
-
-    do {
-      try initializeUpdatesDirectory()
-      try initializeUpdatesDatabase()
-    } catch {
-      emergencyLaunch(fatalError: error as NSError)
-      return
-    }
+  @objc func start()
+}
 
-    UpdatesBuildData.ensureBuildDataIsConsistentAsync(database: database, config: config)
+public protocol InternalAppControllerInterface: AppControllerInterface {
+  var updatesDirectory: URL? { get }
+
+  func getConstantsForModule() -> UpdatesModuleConstants
+  func requestRelaunch(
+    success successBlockArg: @escaping () -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  )
+  func checkForUpdate(
+    success successBlockArg: @escaping (_ remoteCheckResult: RemoteCheckResult) -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  )
+  func fetchUpdate(
+    success successBlockArg: @escaping (_ fetchUpdateResult: FetchUpdateResult) -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  )
+  func getExtraParams(
+    success successBlockArg: @escaping (_ extraParams: [String: String]?) -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  )
+  func setExtraParam(
+    key: String,
+    value: String?,
+    success successBlockArg: @escaping () -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  )
+  func getNativeStateMachineContext(
+    success successBlockArg: @escaping (_ stateMachineContext: UpdatesStateContext) -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  )
+}
 
-    errorRecovery.startMonitoring()
+@objc(EXUpdatesAppControllerDelegate)
+public protocol AppControllerDelegate: AnyObject {
+  func appController(_ appController: AppControllerInterface, didStartWithSuccess success: Bool)
+}
 
-    loaderTask = AppLoaderTask(
-      withConfig: config,
-      database: database,
-      directory: updatesDirectory!,
-      selectionPolicy: selectionPolicy(),
-      delegateQueue: controllerQueue
-    )
-    loaderTask!.delegate = self
-    loaderTask!.swiftDelegate = self
-    loaderTask!.start()
+/**
+ * Main entry point to expo-updates. Singleton that keeps track of updates state, holds references
+ * to instances of other updates classes, and is the central hub for all updates-related tasks.
+ *
+ * The `start` method in the singleton instance of [IUpdatesController] should be invoked early in
+ * the application lifecycle, via [UpdatesPackage]. It delegates to an instance of [LoaderTask] to
+ * start the process of loading and launching an update, then responds appropriately depending on
+ * the callbacks that are invoked.
+ *
+ * This class also optionally holds a reference to the app's [ReactNativeHost], which allows
+ * expo-updates to reload JS and send events through the bridge.
+ */
+@objc(EXUpdatesAppController)
+@objcMembers
+public class AppController: NSObject {
+  public static func isInitialized() -> Bool {
+    return _sharedInstance != nil
   }
-
-  /**
-   Starts the update process to launch a previously-loaded update and (if configured to do so)
-   check for a new update from the server. This method should be called as early as possible in
-   the application's lifecycle.
-
-   Note that iOS may stop showing the app's splash screen in case the update is taking a while
-   to load. This method will attempt to find `LaunchScreen.xib` and load it into view while the
-   update is loading.
-   */
-  public func startAndShowLaunchScreen(_ window: UIWindow) {
-    var view: UIView?
-    let mainBundle = Bundle.main
-    let launchScreen = mainBundle.object(forInfoDictionaryKey: "UILaunchStoryboardName") as? String ?? "LaunchScreen"
-
-    if mainBundle.path(forResource: launchScreen, ofType: "nib") != nil {
-      let views = mainBundle.loadNibNamed(launchScreen, owner: self)
-      view = views?.first as? UIView
-      view?.autoresizingMask = [.flexibleWidth, .flexibleHeight]
-    } else if mainBundle.path(forResource: launchScreen, ofType: "storyboard") != nil ||
-      mainBundle.path(forResource: launchScreen, ofType: "storyboardc") != nil {
-      let launchScreenStoryboard = UIStoryboard(name: launchScreen, bundle: nil)
-      let viewController = launchScreenStoryboard.instantiateInitialViewController()
-      view = viewController?.view
-      viewController?.view = nil
-    } else {
-      NSLog("Launch screen could not be loaded from a .xib or .storyboard. Unexpected loading behavior may occur.")
-      view = UIView()
-      view?.backgroundColor = .white
-    }
-
-    if window.rootViewController == nil {
-      window.rootViewController = UIViewController()
-    }
-    window.rootViewController!.view = view
-    window.makeKeyAndVisible()
-
-    start()
+  private static var _sharedInstance: InternalAppControllerInterface?
+  public static var sharedInstance: InternalAppControllerInterface {
+    assert(_sharedInstance != nil, "AppController.sharedInstace was called before the module was initialized")
+    return _sharedInstance!
   }
 
-  public func requestRelaunch(completion: @escaping EXUpdatesAppRelaunchCompletionBlock) {
-    stateMachine?.processEvent(UpdatesStateEventRestart())
-    let launcherWithDatabase = AppLauncherWithDatabase(
-      config: config,
-      database: database,
-      directory: updatesDirectory!,
-      completionQueue: controllerQueue
-    )
-    candidateLauncher = launcherWithDatabase
-    launcherWithDatabase.launchUpdate(withSelectionPolicy: selectionPolicy()) { error, success in
-      if success {
-        self.launcher = self.candidateLauncher
-        completion(true)
-        self.errorRecovery.startMonitoring()
-        RCTReloadCommandSetBundleURL(self.launcher!.launchAssetUrl)
-        RCTTriggerReloadCommandListeners("Requested by JavaScript - Updates.reloadAsync()")
-        self.runReaper()
-        // Reset the state machine
-        self.stateMachine?.reset()
-      } else {
-        NSLog("Failed to relaunch: %@", error!.localizedDescription)
-        completion(false)
-      }
+  public static func initializeWithoutStarting(configuration: [String: Any]?) {
+    if _sharedInstance != nil {
+      return
     }
-  }
-
-  public func launchedUpdate() -> Update? {
-    return launcher?.launchedUpdate
-  }
 
-  // MARK: - AppLoaderTaskDelegate
-
-  public func appLoaderTask(_: AppLoaderTask, didLoadCachedUpdate update: Update) -> Bool {
-    return true
-  }
-
-  public func appLoaderTaskDidStartCheckingForRemoteUpdate(_: AppLoaderTask) {
-    stateMachine?.processEvent(UpdatesStateEventCheck())
-  }
+    if UpdatesConfig.canCreateValidConfiguration(mergingOtherDictionary: configuration) {
+      var config: UpdatesConfig?
+      do {
+        config = try UpdatesConfig.configWithExpoPlist(mergingOtherDictionary: configuration)
+      } catch {
+        NSException(
+          name: .internalInconsistencyException,
+          reason: "Cannot load configuration from Expo.plist. Please ensure you've followed the setup and installation instructions for expo-updates to create Expo.plist and add it to your Xcode project."
+        )
+        .raise()
+      }
 
-  public func appLoaderTask(_: AppLoaderTask, didFinishCheckingForRemoteUpdateWithRemoteCheckResult remoteCheckResult: RemoteCheckResult) {
-    let event: UpdatesStateEvent
-    switch remoteCheckResult {
-    case .noUpdateAvailable(let _): // Not using reason to update state yet
-      event = UpdatesStateEventCheckComplete()
-    case .updateAvailable(let manifest):
-      event = UpdatesStateEventCheckCompleteWithUpdate(manifest: manifest)
-    case .rollBackToEmbedded(let commitTime):
-      event = UpdatesStateEventCheckCompleteWithRollback(rollbackCommitTime: commitTime)
-    case .error(let error):
-      event = UpdatesStateEventCheckError(message: error.localizedDescription)
+      let updatesDatabase = UpdatesDatabase()
+      do {
+        let directory = try initializeUpdatesDirectory()
+        try initializeUpdatesDatabase(updatesDatabase: updatesDatabase, inUpdatesDirectory: directory)
+        _sharedInstance = EnabledAppController(config: config!, database: updatesDatabase, updatesDirectory: directory)
+      } catch {
+        _sharedInstance = DisabledAppController(error: error, isMissingRuntimeVersion: UpdatesConfig.isMissingRuntimeVersion(mergingOtherDictionary: configuration))
+        return
+      }
+    } else {
+      _sharedInstance = DisabledAppController(error: nil, isMissingRuntimeVersion: UpdatesConfig.isMissingRuntimeVersion(mergingOtherDictionary: configuration))
     }
-    stateMachine?.processEvent(event)
-  }
-
-  public func appLoaderTask(_: AppLoaderTask, didStartLoadingUpdate update: Update?) {
-    logger.info(message: "AppController appLoaderTask didStartLoadingUpdate", code: .none, updateId: update?.loggingId(), assetId: nil)
-    stateMachine?.processEvent(UpdatesStateEventDownload())
   }
 
-  public func appLoaderTask(_: AppLoaderTask, didFinishWithLauncher launcher: AppLauncher, isUpToDate: Bool) {
-    let logMessage = String(
-      format: "AppController appLoaderTask didFinishWithLauncher, isUpToDate=%d, remoteLoadStatus=%ld",
-      isUpToDate,
-      remoteLoadStatus.rawValue
-    )
-    logger.info(message: logMessage)
+  public static func initializeAsDevLauncherWithoutStarting() -> DevLauncherAppController {
+    assert(_sharedInstance == nil, "UpdatesController must not be initialized prior to calling initializeAsDevLauncherWithoutStarting")
 
-    // if isUpToDate is false, that means a remote update is still loading in the background (this
-    // method was called with a cached update because the timer ran out) so don't update the status
-
-    if remoteLoadStatus == .Loading && isUpToDate {
-      remoteLoadStatus = .Idle
+    var config: UpdatesConfig?
+    if UpdatesConfig.canCreateValidConfiguration(mergingOtherDictionary: nil) {
+      config = try? UpdatesConfig.configWithExpoPlist(mergingOtherDictionary: nil)
     }
 
-    self.launcher = launcher
-
-    delegate.let { it in
-      UpdatesUtils.runBlockOnMainThread {
-        it.appController(self, didStartWithSuccess: true)
-        self.sendQueuedEventsToBridge()
-      }
+    var updatesDirectory: URL?
+    let updatesDatabase = UpdatesDatabase()
+    var directoryDatabaseException: Error?
+    do {
+      updatesDirectory = try initializeUpdatesDirectory()
+      try initializeUpdatesDatabase(updatesDatabase: updatesDatabase, inUpdatesDirectory: updatesDirectory!)
+    } catch {
+      directoryDatabaseException = error
     }
-  }
 
-  public func appLoaderTask(_: AppLoaderTask, didLoadAsset asset: UpdateAsset, successfulAssetCount: Int, failedAssetCount: Int, totalAssetCount: Int) {
-    let body = [
-      "assetInfo": [
-        "name": asset.filename,
-        "successfulAssetCount": successfulAssetCount,
-        "failedAssetCount": failedAssetCount,
-        "totalAssetCount": totalAssetCount
-      ] as [String: Any]
-    ]
-    logger.info(
-      message: "AppController appLoaderTask didLoadAsset: \(body)",
-      code: .none,
-      updateId: nil,
-      assetId: asset.contentHash
+    let appController = DevLauncherAppController(
+      initialUpdatesConfiguration: config,
+      updatesDirectory: updatesDirectory,
+      updatesDatabase: updatesDatabase,
+      directoryDatabaseException: directoryDatabaseException,
+      isMissingRuntimeVersion: UpdatesConfig.isMissingRuntimeVersion(mergingOtherDictionary: nil)
     )
+    _sharedInstance = appController
+    return appController
   }
 
-  public func appLoaderTask(_: AppLoaderTask, didFinishWithError error: Error) {
-    let logMessage = String(format: "AppController appLoaderTask didFinishWithError: %@", error.localizedDescription)
-    logger.error(message: logMessage, code: .updateFailedToLoad)
-    stateMachine?.processEvent(UpdatesStateEventDownloadError(message: error.localizedDescription))
-    // Send legacy UpdateEvents to JS
-    sendLegacyUpdateEventToBridge(AppController.ErrorEventName, body: [
-      "message": error.localizedDescription
-    ])
-    emergencyLaunch(fatalError: error as NSError)
+  private static func initializeUpdatesDirectory() throws -> URL {
+    return try UpdatesUtils.initializeUpdatesDirectory()
   }
 
-  public func appLoaderTask(
-    _: AppLoaderTask,
-    didFinishBackgroundUpdateWithStatus status: BackgroundUpdateStatus,
-    update: Update?,
-    error: Error?
-  ) {
-    switch status {
-    case .error:
-      remoteLoadStatus = .Idle
-      guard let error = error else {
-        preconditionFailure("Background update with error status must have a nonnull error object")
-      }
-      logger.error(
-        message: "AppController appLoaderTask didFinishBackgroundUpdateWithStatus=Error",
-        code: .updateFailedToLoad,
-        updateId: update?.loggingId(),
-        assetId: nil
-      )
-      // Since errors can happen through a number of paths, we do these checks
-      // to make sure the state machine is valid
-      if stateMachine?.state == .checking {
-        stateMachine?.processEvent(UpdatesStateEventCheckError(message: error.localizedDescription))
-      } else if stateMachine?.state == .downloading {
-        // .downloading
-        stateMachine?.processEvent(UpdatesStateEventDownloadError(message: error.localizedDescription))
-      }
-      // Send UpdateEvents to JS
-      sendLegacyUpdateEventToBridge(AppController.ErrorEventName, body: [
-        "message": error.localizedDescription
-      ])
-    case .updateAvailable:
-      remoteLoadStatus = .NewUpdateLoaded
-      guard let update = update else {
-        preconditionFailure("Background update with error status must have a nonnull update object")
-      }
-      logger.info(
-        message: "AppController appLoaderTask didFinishBackgroundUpdateWithStatus=NewUpdateLoaded",
-        code: .none,
-        updateId: update.loggingId(),
-        assetId: nil
-      )
-      stateMachine?.processEvent(UpdatesStateEventDownloadCompleteWithUpdate(manifest: update.manifest.rawManifestJSON()))
-      // Send UpdateEvents to JS
-      sendLegacyUpdateEventToBridge(AppController.UpdateAvailableEventName, body: [
-        "manifest": update.manifest.rawManifestJSON()
-      ])
-    case .noUpdateAvailable:
-      remoteLoadStatus = .Idle
-      logger.info(
-        message: "AppController appLoaderTask didFinishBackgroundUpdateWithStatus=NoUpdateAvailable",
-        code: .noUpdatesAvailable,
-        updateId: update?.loggingId(),
-        assetId: nil
-      )
-      // TODO: handle rollbacks properly, but this works for now
-      if stateMachine?.state == .downloading {
-        stateMachine?.processEvent(UpdatesStateEventDownloadComplete())
-      }
-      // Otherwise, we don't need to call the state machine here, it already transitioned to .checkCompleteUnavailable
-      // Send UpdateEvents to JS
-      sendLegacyUpdateEventToBridge(AppController.NoUpdateAvailableEventName, body: [:])
-    }
-
-    errorRecovery.notify(newRemoteLoadStatus: remoteLoadStatus)
-  }
-
-  // MARK: - Internal
-
-  internal func initializeUpdatesDirectory() throws {
-    updatesDirectory = try UpdatesUtils.initializeUpdatesDirectory()
-  }
-
-  internal func initializeUpdatesDatabase() throws {
+  private static func initializeUpdatesDatabase(updatesDatabase: UpdatesDatabase, inUpdatesDirectory updatesDirectory: URL) throws {
     var dbError: Error?
     let semaphore = DispatchSemaphore(value: 0)
-    database.databaseQueue.async {
+    updatesDatabase.databaseQueue.async {
       do {
-        try self.database.openDatabase(inDirectory: self.updatesDirectory!)
+        try updatesDatabase.openDatabase(inDirectory: updatesDirectory)
       } catch {
         dbError = error
       }
@@ -517,204 +215,9 @@ public class AppController: NSObject, AppLoaderTaskDelegate, AppLoaderTaskSwiftD
       throw dbError
     }
   }
-
-  private func purgeUpdatesLogsOlderThanOneDay() {
-    UpdatesUtils.purgeUpdatesLogsOlderThanOneDay()
-  }
-
-  internal func setConfigurationInternal(config: UpdatesConfig) {
-    self.config = config
-  }
-
-  internal func runReaper() {
-    if let launchedUpdate = launcher?.launchedUpdate {
-      UpdatesReaper.reapUnusedUpdates(
-        withConfig: config,
-        database: database,
-        directory: updatesDirectory!,
-        selectionPolicy: selectionPolicy(),
-        launchedUpdate: launchedUpdate
-      )
-    }
-  }
-
-  private func emergencyLaunch(fatalError error: NSError) {
-    isEmergencyLaunch = true
-
-    let launcherNoDatabase = AppLauncherNoDatabase()
-    launcher = launcherNoDatabase
-    launcherNoDatabase.launchUpdate(withConfig: config)
-
-    delegate.let { _ in
-      DispatchQueue.main.async { [weak self] in
-        if let strongSelf = self {
-          strongSelf.delegate?.appController(strongSelf, didStartWithSuccess: strongSelf.launchAssetUrl() != nil)
-          strongSelf.sendQueuedEventsToBridge()
-        }
-      }
-    }
-
-    errorRecovery.writeErrorOrExceptionToLog(error)
-  }
-
-  // MARK: - Send events to JS
-
-  internal func sendLegacyUpdateEventToBridge(_ eventType: String, body: [String: Any] ) {
-    logger.info(message: "sendLegacyUpdateEventToBridge(): type = \(eventType)")
-    sendEventToBridge(AppController.EXUpdatesEventName, eventType, body: body)
-  }
-
-  internal func sendUpdateStateChangeEventToBridge(_ eventType: UpdatesStateEventType, body: [String: Any?]) {
-    logger.info(message: "sendUpdateStateChangeEventToBridge(): type = \(eventType)")
-    sendEventToBridge(AppController.EXUpdatesStateChangeEventName, "\(eventType)", body: body)
-  }
-
-  private func sendEventToBridge(_ eventName: String, _ eventType: String, body: [String: Any?]) {
-    var mutableBody = body
-    mutableBody["type"] = eventType
-
-    guard let bridge = bridge else {
-      eventsToSendToJS.append([
-        "eventName": eventName,
-        "mutableBody": mutableBody
-      ])
-      logger.warn(message: "EXUpdates: Could not emit event: name = \(eventName), type = \(eventType). Event will be emitted when the bridge is available", code: .jsRuntimeError)
-      return
-    }
-    logger.debug(message: "sendEventToBridge: \(eventName), \(mutableBody)")
-    bridge.enqueueJSCall("RCTDeviceEventEmitter.emit", args: [eventName, mutableBody])
-  }
-
-  internal func sendQueuedEventsToBridge() {
-    guard let bridge = bridge else {
-      return
-    }
-    eventsToSendToJS.forEach { event in
-      guard let eventName = event["eventName"] as? String,
-        let mutableBody = event["mutableBody"] as? [String: Any?] else {
-        return
-      }
-      logger.debug(message: "sendEventToBridge: \(eventName), \(mutableBody)")
-      bridge.enqueueJSCall("RCTDeviceEventEmitter.emit", args: [eventName, mutableBody])
-    }
-    eventsToSendToJS = []
-  }
-
-  // MARK: - ErrorRecoveryDelegate
-
-  public func relaunch(completion: @escaping (Error?, Bool) -> Void) {
-    let launcher = AppLauncherWithDatabase(
-      config: config,
-      database: database,
-      directory: updatesDirectory!,
-      completionQueue: controllerQueue
-    )
-    candidateLauncher = launcher
-    launcher.launchUpdate(withSelectionPolicy: selectionPolicy()) { error, success in
-      if success {
-        self.launcher = self.candidateLauncher
-        self.errorRecovery.startMonitoring()
-        RCTReloadCommandSetBundleURL(launcher.launchAssetUrl)
-        RCTTriggerReloadCommandListeners("Relaunch after fatal error")
-        completion(nil, true)
-      } else {
-        completion(error, false)
-      }
-    }
-  }
-
-  public func loadRemoteUpdate() {
-    if let loaderTask = loaderTask, loaderTask.isRunning {
-      return
-    }
-
-    remoteLoadStatus = .Loading
-
-    let remoteAppLoader = RemoteAppLoader(
-      config: config,
-      database: database,
-      directory: updatesDirectory!,
-      launchedUpdate: launchedUpdate(),
-      completionQueue: controllerQueue
-    )
-    remoteAppLoader.loadUpdate(
-      fromURL: config.updateUrl!
-    ) { updateResponse in
-      if let updateDirective = updateResponse.directiveUpdateResponsePart?.updateDirective {
-        switch updateDirective {
-        case is NoUpdateAvailableUpdateDirective:
-          return false
-        case is RollBackToEmbeddedUpdateDirective:
-          return false
-        default:
-          NSException(name: .internalInconsistencyException, reason: "Unhandled update directive type").raise()
-          return false
-        }
-      }
-
-      guard let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
-        return false
-      }
-
-      return self.selectionPolicy().shouldLoadNewUpdate(update, withLaunchedUpdate: self.launchedUpdate(), filters: updateResponse.responseHeaderData?.manifestFilters)
-    } asset: { _, _, _, _ in
-      // do nothing for now
-    } success: { updateResponse in
-      self.remoteLoadStatus = updateResponse != nil ? .NewUpdateLoaded : .Idle
-      self.errorRecovery.notify(newRemoteLoadStatus: self.remoteLoadStatus)
-    } error: { error in
-      self.logger.error(message: "AppController loadRemoteUpdate error: \(error.localizedDescription)", code: .updateFailedToLoad)
-      self.remoteLoadStatus = .Idle
-      self.errorRecovery.notify(newRemoteLoadStatus: self.remoteLoadStatus)
-    }
-  }
-
-  public func markFailedLaunchForLaunchedUpdate() {
-    if isEmergencyLaunch {
-      return
-    }
-
-    database.databaseQueue.async {
-      guard let launchedUpdate = self.launchedUpdate() else {
-        return
-      }
-
-      self.logger.error(
-        message: "AppController markFailedLaunchForUpdate",
-        code: .unknown,
-        updateId: launchedUpdate.loggingId(),
-        assetId: nil
-      )
-      do {
-        try self.database.incrementFailedLaunchCountForUpdate(launchedUpdate)
-      } catch {
-        NSLog("Unable to mark update as failed in the local DB: %@", error.localizedDescription)
-      }
-    }
-  }
-
-  public func markSuccessfulLaunchForLaunchedUpdate() {
-    if isEmergencyLaunch {
-      return
-    }
-
-    database.databaseQueue.async {
-      guard let launchedUpdate = self.launchedUpdate() else {
-        return
-      }
-
-      do {
-        try self.database.incrementSuccessfulLaunchCountForUpdate(launchedUpdate)
-      } catch {
-        NSLog("Failed to increment successful launch count for update: %@", error.localizedDescription)
-      }
-    }
-  }
-
-  public func throwException(_ exception: NSException) {
-    exception.raise()
-  }
 }
 
-// swiftlint:enable line_length
 // swiftlint:enable force_unwrapping
+// swiftlint:enable closure_body_length
+// swiftlint:enable line_length
+// swiftlint:enable type_body_length
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncher.swift b/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncher.swift
index 32b6db6..517cec7 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncher.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncher.swift
@@ -13,7 +13,7 @@ public typealias AppLauncherCompletionBlock = (_ error: Error?, _ success: Bool)
 public protocol AppLauncher {
   @objc var launchedUpdate: Update? { get }
   @objc var launchAssetUrl: URL? { get }
-  @objc var assetFilesMap: [String: Any]? { get }
+  @objc var assetFilesMap: [String: String]? { get }
 
   @objc func isUsingEmbeddedAssets() -> Bool
 }
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncherNoDatabase.swift b/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncherNoDatabase.swift
index fe07a93..5543415 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncherNoDatabase.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncherNoDatabase.swift
@@ -17,34 +17,16 @@ import Foundation
 public final class AppLauncherNoDatabase: NSObject, AppLauncher {
   public var launchedUpdate: Update?
   public var launchAssetUrl: URL?
-  public var assetFilesMap: [String: Any]?
+  public var assetFilesMap: [String: String]?
 
   public override init() {}
 
-  public func launchUpdate(withConfig config: UpdatesConfig) {
-    launchedUpdate = EmbeddedAppLoader.embeddedManifest(withConfig: config, database: nil)
-    if let launchedUpdate = launchedUpdate {
-      if launchedUpdate.status == UpdateStatus.StatusEmbedded {
-        precondition(assetFilesMap == nil, "assetFilesMap should be null for embedded updates")
-        launchAssetUrl = Bundle.main.url(
-          forResource: EmbeddedAppLoader.EXUpdatesBareEmbeddedBundleFilename,
-          withExtension: EmbeddedAppLoader.EXUpdatesBareEmbeddedBundleFileType
-        )
-      } else {
-        launchAssetUrl = Bundle.main.url(
-          forResource: EmbeddedAppLoader.EXUpdatesEmbeddedBundleFilename,
-          withExtension: EmbeddedAppLoader.EXUpdatesEmbeddedBundleFileType
-        )
-
-        var assetFilesMapLocal: [String: String] = [:]
-        for asset in launchedUpdate.assets()! {
-          if let assetKey = asset.key, let localUrl = UpdatesUtils.url(forBundledAsset: asset) {
-            assetFilesMapLocal[assetKey] = localUrl.absoluteString
-          }
-        }
-        assetFilesMap = assetFilesMapLocal
-      }
-    }
+  public func launchUpdate() {
+    precondition(assetFilesMap == nil, "assetFilesMap should be null for embedded updates")
+    launchAssetUrl = Bundle.main.url(
+      forResource: EmbeddedAppLoader.EXUpdatesBareEmbeddedBundleFilename,
+      withExtension: EmbeddedAppLoader.EXUpdatesBareEmbeddedBundleFileType
+    )
   }
 
   public func isUsingEmbeddedAssets() -> Bool {
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncherWithDatabase.swift b/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncherWithDatabase.swift
index b7f3d0f..07c9e79 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncherWithDatabase.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppLauncher/AppLauncherWithDatabase.swift
@@ -1,14 +1,11 @@
 //  Copyright © 2019 650 Industries. All rights reserved.
 
-// swiftlint:disable type_body_length
 // swiftlint:disable closure_body_length
 // swiftlint:disable force_unwrapping
-// swiftlint:disable type_name
 
 import Foundation
 
 public typealias AppLauncherUpdateCompletionBlock = (_ error: Error?, _ update: Update?) -> Void
-public typealias AppLauncherQueryCompletionBlock = (_ error: Error?, _ updateIds: [UUID]?) -> Void
 
 /**
  * Implementation of AppLauncher that uses the SQLite database and expo-updates file store
@@ -35,13 +32,14 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
 
   public var launchedUpdate: Update?
   public var launchAssetUrl: URL?
-  public var assetFilesMap: [String: Any]?
+  public var assetFilesMap: [String: String]?
 
   private let launcherQueue: DispatchQueue
   private var completedAssets: Int
   private let config: UpdatesConfig
   private let database: UpdatesDatabase
   private let directory: URL
+  private let logger: UpdatesLogger
   public private(set) var completionQueue: DispatchQueue
   public private(set) var completion: AppLauncherCompletionBlock?
 
@@ -54,6 +52,7 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
     self.database = database
     self.directory = directory
     self.completionQueue = completionQueue
+    self.logger = UpdatesLogger()
   }
 
   public func isUsingEmbeddedAssets() -> Bool {
@@ -79,7 +78,7 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
       var manifestFilters: [String: Any]?
       var manifestFiltersError: Error?
       do {
-        manifestFilters = try database.manifestFilters(withScopeKey: config.scopeKey!)
+        manifestFilters = try database.manifestFilters(withScopeKey: config.scopeKey)
       } catch {
         manifestFiltersError = error
       }
@@ -159,20 +158,6 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
     }
   }
 
-  public static func storedUpdateIds(
-    inDatabase database: UpdatesDatabase,
-    completion: @escaping AppLauncherQueryCompletionBlock
-  ) {
-    database.databaseQueue.async {
-      do {
-        let readyUpdateIds = try database.allUpdateIds(withStatus: .StatusReady)
-        completion(nil, readyUpdateIds)
-      } catch {
-        completion(error, nil)
-      }
-    }
-  }
-
   private func finishLaunch() {
     markUpdateAccessed()
     ensureAllAssetsExist()
@@ -186,7 +171,7 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
       do {
         try self.database.markUpdateAccessed(self.launchedUpdate!)
       } catch {
-        NSLog("Failed to mark update as recently accessed: %@", error.localizedDescription)
+        self.logger.warn(message: "Failed to mark update as recently accessed: \(error.localizedDescription)")
       }
     }
   }
@@ -208,7 +193,9 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
         self.completion = nil
       }
       return
-    } else if launchedUpdate.status == UpdateStatus.StatusDevelopment {
+    }
+
+    if launchedUpdate.status == UpdateStatus.StatusDevelopment {
       completionQueue.async {
         self.completion!(nil, true)
         self.completion = nil
@@ -216,7 +203,8 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
       return
     }
 
-    assetFilesMap = [:]
+    // Initialize asset map with the embedded assets that may not be part of this update
+    self.assetFilesMap = UpdatesUtils.embeddedAssetsMap(withConfig: config, database: database, logger: logger)
 
     let assets = launchedUpdate.assets()!
     let totalAssetCount = assets.count
@@ -260,7 +248,7 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
         }
 
         if let error = error {
-          NSLog("Error copying embedded asset %@: %@", [asset.key, error.localizedDescription])
+          self.logger.warn(message: "AppLauncherWithDatabase: Error copying embedded asset \(asset.key ?? ""): \(error.localizedDescription)")
         }
 
         self.downloadAsset(asset, withLocalUrl: assetLocalUrl) { downloadAssetError, downloadAssetAsset, _ in
@@ -270,7 +258,7 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
               // so we want to propagate this error
               self.launchAssetError = downloadAssetError
             }
-            NSLog("Failed to load missing asset %@: %@", [downloadAssetAsset.key, downloadAssetError.localizedDescription])
+            self.logger.warn(message: "AppLauncherWithDatabase: Failed to load missing asset \(downloadAssetAsset.key ?? ""): \(downloadAssetError.localizedDescription)")
             completion(false)
           } else {
             // attempt to update the database record to match the newly downloaded asset
@@ -279,7 +267,7 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
               do {
                 try self.database.updateAsset(downloadAssetAsset)
               } catch {
-                NSLog("Could not write data for downloaded asset to database: %@", [error.localizedDescription])
+                self.logger.warn(message: "AppLauncherWithDatabase: Could not write data for downloaded asset to database: \(error.localizedDescription)")
               }
             }
             completion(true)
@@ -347,10 +335,9 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
         }
       }
       return
-    } else {
-      self.launcherQueue.async {
-        completion(false, nil)
-      }
+    }
+    self.launcherQueue.async {
+      completion(false, nil)
     }
   }
 
@@ -395,3 +382,5 @@ public class AppLauncherWithDatabase: NSObject, AppLauncher {
     FileDownloader(config: config)
   }()
 }
+// swiftlint:enable closure_body_length
+// swiftlint:enable force_unwrapping
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppLoader/AppLoader.swift b/node_modules/expo-updates/ios/EXUpdates/AppLoader/AppLoader.swift
index be72c1b..e535c95 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppLoader/AppLoader.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppLoader/AppLoader.swift
@@ -4,8 +4,6 @@
 // swiftlint:disable unavailable_function
 
 // swiftlint:disable closure_body_length
-// swiftlint:disable function_body_length
-// swiftlint:disable type_body_length
 
 // this class uses a lot of implicit non-null stuff across function calls. not worth refactoring to just satisfy lint
 // swiftlint:disable force_unwrapping
@@ -325,13 +323,19 @@ open class AppLoader: NSObject {
           // the database and filesystem have gotten out of sync
           // do our best to create a new entry for this file even though it already existed on disk
           // TODO: we should probably get rid of this assumption that if an asset exists on disk with the same filename, it's the same asset
-
-          // this has always force-tried implicitly, could probably do some better error handling
-          // swiftlint:disable:next force_try
-          let contents = try! Data(contentsOf: self.directory.appendingPathComponent(existingAsset.filename))
-          existingAsset.contentHash = UpdatesUtils.hexEncodedSHA256WithData(contents)
-          existingAsset.downloadTime = Date()
-          self.finishedAssets.append(existingAsset)
+          var contents = try? Data(contentsOf: self.directory.appendingPathComponent(existingAsset.filename))
+          if contents == nil {
+            if let embeddedUrl = UpdatesUtils.url(forBundledAsset: existingAsset) {
+              contents = try? Data(contentsOf: embeddedUrl)
+            }
+          }
+          // This replaces the old force try
+          assert(contents != nil)
+          if let contents = contents {
+            existingAsset.contentHash = UpdatesUtils.hexEncodedSHA256WithData(contents)
+            existingAsset.downloadTime = Date()
+            self.finishedAssets.append(existingAsset)
+          }
         }
       }
 
@@ -387,3 +391,7 @@ open class AppLoader: NSObject {
     }
   }
 }
+
+// swiftlint:enable unavailable_function
+// swiftlint:enable closure_body_length
+// swiftlint:enable force_unwrapping
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppLoader/AppLoaderTask.swift b/node_modules/expo-updates/ios/EXUpdates/AppLoader/AppLoaderTask.swift
index 037666e..3d5b90c 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppLoader/AppLoaderTask.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppLoader/AppLoaderTask.swift
@@ -146,38 +146,6 @@ public final class AppLoaderTask: NSObject {
   }
 
   public func start() {
-    guard config.isEnabled else {
-      let errorMessage = "AppLoaderTask was passed a configuration object with updates disabled. You should load updates from an embedded source rather than calling AppLoaderTask, or enable updates in the configuration."
-      logger.error(message: errorMessage, code: .updateFailedToLoad)
-      delegateQueue.async {
-        self.delegate?.appLoaderTask(
-          self,
-          didFinishWithError: NSError(
-            domain: AppLoaderTask.ErrorDomain,
-            code: 1030,
-            userInfo: [NSLocalizedDescriptionKey: errorMessage]
-          )
-        )
-      }
-      return
-    }
-
-    guard config.updateUrl != nil else {
-      let errorMessage = "AppLoaderTask was passed a configuration object with a null URL. You must pass a nonnull URL in order to use AppLoaderTask to load updates."
-      logger.error(message: errorMessage, code: .updateFailedToLoad)
-      delegateQueue.async {
-        self.delegate?.appLoaderTask(
-          self,
-          didFinishWithError: NSError(
-            domain: AppLoaderTask.ErrorDomain,
-            code: 1030,
-            userInfo: [NSLocalizedDescriptionKey: errorMessage]
-          )
-        )
-      }
-      return
-    }
-
     isRunning = true
 
     var shouldCheckForUpdate = UpdatesUtils.shouldCheckForUpdate(withConfig: config)
@@ -305,7 +273,7 @@ public final class AppLoaderTask: NSObject {
         var manifestFiltersError: Error?
         var manifestFilters: [String: Any]?
         do {
-          manifestFilters = try self.database.manifestFilters(withScopeKey: self.config.scopeKey!)
+          manifestFilters = try self.database.manifestFilters(withScopeKey: self.config.scopeKey)
         } catch {
           manifestFiltersError = error
         }
@@ -371,7 +339,7 @@ public final class AppLoaderTask: NSObject {
       }
     }
     remoteAppLoader!.loadUpdate(
-      fromURL: config.updateUrl!
+      fromURL: config.updateUrl
     ) { updateResponse in
       if let updateDirective = updateResponse.directiveUpdateResponsePart?.updateDirective {
         switch updateDirective {
@@ -390,7 +358,7 @@ public final class AppLoaderTask: NSObject {
             self.delegateQueue.async {
               swiftDelegate.appLoaderTask(
                 self, didFinishCheckingForRemoteUpdateWithRemoteCheckResult: RemoteCheckResult.rollBackToEmbedded(
-                  commitTime: RollBackToEmbeddedUpdateDirective.rollbackCommitTime(rollBackUpdateDirective)
+                  commitTime: rollBackUpdateDirective.commitTime
                 )
               )
             }
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppLoader/EmbeddedAppLoader.swift b/node_modules/expo-updates/ios/EXUpdates/AppLoader/EmbeddedAppLoader.swift
index f9ed69d..a4a53ae 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppLoader/EmbeddedAppLoader.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppLoader/EmbeddedAppLoader.swift
@@ -1,6 +1,5 @@
 //  Copyright © 2019 650 Industries. All rights reserved.
 
-// swiftlint:disable identifier_name
 // swiftlint:disable legacy_objc_type
 
 // this class uses an abstract class pattern
@@ -30,8 +29,8 @@ public final class EmbeddedAppLoader: AppLoader {
 
   private static let ErrorDomain = "EXUpdatesEmbeddedAppLoader"
 
-  private static var embeddedManifestInternal: Update?
-  public static func embeddedManifest(withConfig config: UpdatesConfig, database: UpdatesDatabase?) -> Update? {
+  private static var embeddedManifestInternal: BareUpdate?
+  public static func embeddedManifest(withConfig config: UpdatesConfig, database: UpdatesDatabase?) -> BareUpdate? {
     guard config.hasEmbeddedUpdate else {
       return nil
     }
@@ -129,35 +128,8 @@ public final class EmbeddedAppLoader: AppLoader {
   }
 
   override public func downloadAsset(_ asset: UpdateAsset) {
-    let destinationUrl = directory.appendingPathComponent(asset.filename)
     FileDownloader.assetFilesQueue.async {
-      if FileManager.default.fileExists(atPath: destinationUrl.path) {
-        DispatchQueue.global().async {
-          self.handleAssetDownloadAlreadyExists(asset)
-        }
-      } else {
-        let mainBundleFilename = asset.mainBundleFilename.require("embedded asset mainBundleFilename must be nonnull")
-        let bundlePath = UpdatesUtils.path(forBundledAsset: asset).require(
-          String(
-            format: "Could not find the expected embedded asset in NSBundle %@.%@. " +
-              "Check that expo-updates is installed correctly, and verify that assets are present in the ipa file.",
-            mainBundleFilename,
-            asset.type ?? ""
-          )
-        )
-
-        do {
-          try FileManager.default.copyItem(atPath: bundlePath, toPath: destinationUrl.path)
-          let data = try NSData(contentsOfFile: bundlePath) as Data
-          DispatchQueue.global().async {
-            self.handleAssetDownload(withData: data, response: nil, asset: asset)
-          }
-        } catch {
-          DispatchQueue.global().async {
-            self.handleAssetDownload(withError: error, asset: asset)
-          }
-        }
-      }
+      self.handleAssetDownloadAlreadyExists(asset)
     }
   }
 
@@ -171,3 +143,6 @@ public final class EmbeddedAppLoader: AppLoader {
     preconditionFailure("Should not call EmbeddedAppLoader#loadUpdateFromUrl")
   }
 }
+
+// swiftlint:enable legacy_objc_type
+// swiftlint:enable unavailable_function
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppLoader/FileDownloader.swift b/node_modules/expo-updates/ios/EXUpdates/AppLoader/FileDownloader.swift
index f3c878d..325e2a1 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppLoader/FileDownloader.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppLoader/FileDownloader.swift
@@ -227,7 +227,7 @@ public final class FileDownloader: NSObject, URLSessionDataDelegate {
     launchedUpdate: Update?,
     embeddedUpdate: Update?
   ) -> [String: Any] {
-    let scopeKey = config.scopeKey.require("Must have scopeKey in config")
+    let scopeKey = config.scopeKey
 
     var extraHeaders: [String: Any] = [:]
     do {
@@ -306,7 +306,7 @@ public final class FileDownloader: NSObject, URLSessionDataDelegate {
     request.setValue(config.expectsSignedManifest ? "true" : "false", forHTTPHeaderField: "Expo-Accept-Signature")
     request.setValue(config.releaseChannel, forHTTPHeaderField: "Expo-Release-Channel")
 
-    if let runtimeVersion = config.runtimeVersion {
+    if let runtimeVersion = config.runtimeVersionRaw {
       request.setValue(runtimeVersion, forHTTPHeaderField: "Expo-Runtime-Version")
     } else {
       request.setValue(config.sdkVersion, forHTTPHeaderField: "Expo-SDK-Version")
@@ -861,7 +861,7 @@ public final class FileDownloader: NSObject, URLSessionDataDelegate {
       userInfo: [
         NSLocalizedDescriptionKey: String(
           format: "No compatible update found at %@. Only %@ are supported.",
-          config.updateUrl?.absoluteString ?? "(missing config updateUrl)",
+          config.updateUrl.absoluteString,
           config.sdkVersion ?? "(missing sdkVersion field)"
         )
       ]
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppLoader/RemoteAppLoader.swift b/node_modules/expo-updates/ios/EXUpdates/AppLoader/RemoteAppLoader.swift
index 3e8a8d6..656faf4 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppLoader/RemoteAppLoader.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppLoader/RemoteAppLoader.swift
@@ -49,8 +49,7 @@ public final class RemoteAppLoader: AppLoader {
         let responseHeaderData = remoteUpdateResponse.responseHeaderData {
         strongSelf.database.databaseQueue.async {
           do {
-            // swiftlint:disable:next force_unwrapping
-            try strongSelf.database.setMetadata(withResponseHeaderData: responseHeaderData, scopeKey: strongSelf.config.scopeKey!)
+            try strongSelf.database.setMetadata(withResponseHeaderData: responseHeaderData, scopeKey: strongSelf.config.scopeKey)
             successBlockArg(updateResponse)
           } catch {
             NSLog("Error persisting header data to disk: %@", error.localizedDescription)
diff --git a/node_modules/expo-updates/ios/EXUpdates/AppLoader/UpdateResponse.swift b/node_modules/expo-updates/ios/EXUpdates/AppLoader/UpdateResponse.swift
index f7614b3..337cf33 100644
--- a/node_modules/expo-updates/ios/EXUpdates/AppLoader/UpdateResponse.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/AppLoader/UpdateResponse.swift
@@ -63,11 +63,6 @@ public final class RollBackToEmbeddedUpdateDirective: UpdateDirective {
     self.commitTime = commitTime
     super.init(signingInfo: signingInfo)
   }
-
-  // Extract commit time from an UpdateDirective
-  internal static func rollbackCommitTime(_ updateDirective: RollBackToEmbeddedUpdateDirective) -> Date {
-    return updateDirective.commitTime
-  }
 }
 
 public class UpdateResponsePart {}
diff --git a/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesBuildData.swift b/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesBuildData.swift
index db0b8b6..1d833da 100644
--- a/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesBuildData.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesBuildData.swift
@@ -28,13 +28,7 @@ import Foundation
 internal final class UpdatesBuildData {
   static func ensureBuildDataIsConsistentAsync(database: UpdatesDatabase, config: UpdatesConfig) {
     database.databaseQueue.async {
-      guard let scopeKey = config.scopeKey else {
-        NSException(
-          name: .internalInconsistencyException,
-          reason: "expo-updates was configured with no scope key. Make sure a valid URL is configured under EXUpdatesURL."
-        ).raise()
-        return
-      }
+      let scopeKey = config.scopeKey
 
       let staticBuildData: [AnyHashable: Any]?
       do {
@@ -64,7 +58,7 @@ internal final class UpdatesBuildData {
 
   static func getBuildDataFromConfig(_ config: UpdatesConfig) -> [String: Any] {
     return [
-      "EXUpdatesURL": config.updateUrl.require("Must supply updateUrl in config").absoluteString,
+      "EXUpdatesURL": config.updateUrl.absoluteString,
       "EXUpdatesReleaseChannel": config.releaseChannel,
       "EXUpdatesRequestHeaders": config.requestHeaders
     ]
diff --git a/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesDatabase.swift b/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesDatabase.swift
index 1ec6b8f..01d1445 100644
--- a/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesDatabase.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesDatabase.swift
@@ -401,15 +401,6 @@ public final class UpdatesDatabase: NSObject {
     }
   }
 
-  public func allUpdateIds(withStatus status: UpdateStatus) throws -> [UUID] {
-    let sql = "SELECT id FROM updates WHERE status = ?1;"
-    let rows = try execute(sql: sql, withArgs: [status.rawValue])
-    return rows.map { row in
-      // swiftlint:disable:next force_cast
-      row["id"] as! UUID
-    }
-  }
-
   public func launchableUpdates(withConfig config: UpdatesConfig) throws -> [Update] {
     // if an update has successfully launched at least once, we treat it as launchable
     // even if it has also failed to launch at least once
diff --git a/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesReaper.swift b/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesReaper.swift
index 1f7303f..7935929 100644
--- a/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesReaper.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/Database/UpdatesReaper.swift
@@ -39,7 +39,7 @@ public final class UpdatesReaper: NSObject {
 
       var manifestFilters: [String: Any]?
       do {
-        manifestFilters = try database.manifestFilters(withScopeKey: config.scopeKey.require("Must have scopeKey in config"))
+        manifestFilters = try database.manifestFilters(withScopeKey: config.scopeKey)
       } catch {
         NSLog("Error selecting manifest filters while reaping updates: %@", [error.localizedDescription])
         return
diff --git a/node_modules/expo-updates/ios/EXUpdates/DevLauncherAppController.swift b/node_modules/expo-updates/ios/EXUpdates/DevLauncherAppController.swift
new file mode 100644
index 0000000..440568d
--- /dev/null
+++ b/node_modules/expo-updates/ios/EXUpdates/DevLauncherAppController.swift
@@ -0,0 +1,318 @@
+//  Copyright © 2019 650 Industries. All rights reserved.
+
+// swiftlint:disable line_length
+// swiftlint:disable force_unwrapping
+
+import EXUpdatesInterface
+import ExpoModulesCore
+
+/**
+ * Main entry point to expo-updates in development builds with expo-dev-client. Similar to EnabledUpdatesController
+ * in that it keeps track of updates state, but provides capabilities that are not usually exposed but
+ * that expo-dev-client needs (launching and downloading a specific
+ * update by URL, allowing dynamic configuration, introspecting the database). The behavior of this
+ * class differs enough that it is implemented independently from EnabledUpdatesController.
+ *
+ * Implements the external UpdatesInterface from the expo-updates-interface package. This allows
+ * expo-dev-client to compile without needing expo-updates to be installed.
+ */
+@objc(EXUpdatesDevLauncherController)
+@objcMembers
+public final class DevLauncherAppController: NSObject, InternalAppControllerInterface, UpdatesExternalInterface {
+  public weak var bridge: AnyObject?
+
+  public var delegate: AppControllerDelegate?
+
+  public func launchAssetUrl() -> URL? {
+    return launcher?.launchAssetUrl
+  }
+
+  private let isEmergencyLaunch: Bool
+  public var launchAssetURL: URL? {
+    launcher?.launchAssetUrl
+  }
+
+  // swiftlint:disable unavailable_function
+  public func start() {
+    preconditionFailure("Cannot call start on DevLauncherAppController")
+  }
+  // swiftlint:enable unavailable_function
+
+  private static let ErrorDomain = "EXUpdatesDevLauncherController"
+
+  enum ErrorCode: Int {
+    case invalidUpdateURL = 1
+    case updateLaunchFailed = 4
+    case configFailed = 5
+  }
+
+  private var previousUpdatesConfiguration: UpdatesConfig?
+  private var config: UpdatesConfig?
+  private let isMissingRuntimeVersion: Bool
+
+  private var directoryDatabaseException: Error?
+  public let updatesDirectory: URL? // internal for E2E test
+  private let database: UpdatesDatabase
+
+  private var launcher: AppLauncher?
+  private let controllerQueue = DispatchQueue(label: "expo.controller.ControllerQueue")
+  public private(set) var isStarted: Bool = false
+
+  private var _selectionPolicy: SelectionPolicy?
+  private var defaultSelectionPolicy: SelectionPolicy
+
+  required init(
+    initialUpdatesConfiguration: UpdatesConfig?,
+    updatesDirectory: URL?,
+    updatesDatabase: UpdatesDatabase,
+    directoryDatabaseException: Error?,
+    isMissingRuntimeVersion: Bool
+  ) {
+    self.config = initialUpdatesConfiguration
+    self.updatesDirectory = updatesDirectory
+    self.database = updatesDatabase
+    self.directoryDatabaseException = directoryDatabaseException
+    self.isEmergencyLaunch = directoryDatabaseException != nil
+    self.isMissingRuntimeVersion = isMissingRuntimeVersion
+
+    self.defaultSelectionPolicy = SelectionPolicyFactory.filterAwarePolicy(
+      withRuntimeVersion: initialUpdatesConfiguration.let { it in it.runtimeVersionRealized } ?? "1"
+    )
+
+    super.init()
+  }
+
+  public func assetFilesMap() -> [String: Any]? {
+    return launcher?.assetFilesMap
+  }
+
+  public func isUsingEmbeddedAssets() -> Bool {
+    guard let launcher = launcher else {
+      return true
+    }
+    return launcher.isUsingEmbeddedAssets()
+  }
+
+  public func reset() {
+    self.launcher = nil
+    self.isStarted = true
+  }
+
+  public func fetchUpdate(
+    withConfiguration configuration: [String: Any],
+    onManifest manifestBlock: @escaping UpdatesManifestBlock,
+    progress progressBlock: @escaping UpdatesProgressBlock,
+    success successBlock: @escaping UpdatesUpdateSuccessBlock,
+    error errorBlock: @escaping UpdatesErrorBlock
+  ) {
+    if let directoryDatabaseException = directoryDatabaseException {
+      errorBlock(directoryDatabaseException)
+      return
+    }
+
+    if !UpdatesConfig.canCreateValidConfiguration(mergingOtherDictionary: configuration) {
+      errorBlock(NSError(
+        domain: DevLauncherAppController.ErrorDomain,
+        code: ErrorCode.invalidUpdateURL.rawValue,
+        userInfo: [
+          NSLocalizedDescriptionKey: "Failed to read stored updates: configuration object must include a valid update URL"
+        ]
+      ))
+      return
+    }
+
+    var updatesConfiguration: UpdatesConfig
+    do {
+      updatesConfiguration = try UpdatesConfig.configWithExpoPlist(mergingOtherDictionary: configuration)
+    } catch {
+      errorBlock(NSError(
+        domain: DevLauncherAppController.ErrorDomain,
+        code: ErrorCode.configFailed.rawValue,
+        userInfo: [
+          NSLocalizedDescriptionKey: "Cannot load configuration from Expo.plist. Please ensure you've followed the setup and installation instructions for expo-updates to create Expo.plist and add it to your Xcode project."
+        ]
+      ))
+      return
+    }
+
+    // since controller is a singleton, save its config so we can reset to it if our request fails
+    self.previousUpdatesConfiguration = self.config
+
+    setDevelopmentSelectionPolicy()
+    self.config = updatesConfiguration
+
+    let loader = RemoteAppLoader(
+      config: updatesConfiguration,
+      database: self.database,
+      directory: self.updatesDirectory!,
+      launchedUpdate: nil,
+      completionQueue: self.controllerQueue
+    )
+    loader.loadUpdate(
+      fromURL: updatesConfiguration.updateUrl
+    ) { updateResponse in
+      if let updateDirective = updateResponse.directiveUpdateResponsePart?.updateDirective {
+        switch updateDirective {
+        case is NoUpdateAvailableUpdateDirective:
+          return false
+        case is RollBackToEmbeddedUpdateDirective:
+          return false
+        default:
+          NSException(name: .internalInconsistencyException, reason: "Unhandled update directive type").raise()
+          return false
+        }
+      }
+
+      guard let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
+        return false
+      }
+
+      return manifestBlock(update.manifest.rawManifestJSON())
+    } asset: { _, successfulAssetCount, failedAssetCount, totalAssetCount in
+      progressBlock(UInt(successfulAssetCount), UInt(failedAssetCount), UInt(totalAssetCount))
+    } success: { updateResponse in
+      guard let updateResponse = updateResponse,
+        let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
+        successBlock(nil)
+        return
+      }
+      self.launch(update: update, withConfiguration: updatesConfiguration, success: successBlock, error: errorBlock)
+    } error: { error in
+      // reset controller's configuration to what it was before this request
+      self.config = self.previousUpdatesConfiguration!
+      errorBlock(error)
+    }
+  }
+
+  public func selectionPolicy() -> SelectionPolicy {
+    if _selectionPolicy == nil {
+      _selectionPolicy = defaultSelectionPolicy
+    }
+    return _selectionPolicy!
+  }
+  public func setNextSelectionPolicy(_ nextSelectionPolicy: SelectionPolicy) {
+    _selectionPolicy = nextSelectionPolicy
+  }
+  public func resetSelectionPolicyToDefault() {
+    _selectionPolicy = nil
+  }
+
+  private func setDevelopmentSelectionPolicy() {
+    resetSelectionPolicyToDefault()
+    let currentSelectionPolicy = selectionPolicy()
+    defaultSelectionPolicy = SelectionPolicy(
+      launcherSelectionPolicy: currentSelectionPolicy.launcherSelectionPolicy,
+      loaderSelectionPolicy: currentSelectionPolicy.loaderSelectionPolicy,
+      reaperSelectionPolicy: ReaperSelectionPolicyDevelopmentClient()
+    )
+    resetSelectionPolicyToDefault()
+  }
+
+  private func launch(
+    update: Update,
+    withConfiguration configuration: UpdatesConfig,
+    success successBlock: @escaping UpdatesUpdateSuccessBlock,
+    error errorBlock: @escaping UpdatesErrorBlock
+  ) {
+    // ensure that we launch the update we want, even if it isn't the latest one
+    let currentSelectionPolicy = selectionPolicy()
+
+    // Calling `setNextSelectionPolicy` allows the Updates module's `reloadAsync` method to reload
+    // with a different (newer) update if one is downloaded, e.g. using `fetchUpdateAsync`. If we set
+    // the default selection policy here instead, the update we are launching here would keep being
+    // launched by `reloadAsync` even if a newer one is downloaded.
+    setNextSelectionPolicy(SelectionPolicy(
+      launcherSelectionPolicy: LauncherSelectionPolicySingleUpdate(updateId: update.updateId),
+      loaderSelectionPolicy: currentSelectionPolicy.loaderSelectionPolicy,
+      reaperSelectionPolicy: currentSelectionPolicy.reaperSelectionPolicy
+    ))
+
+    let launcher = AppLauncherWithDatabase(
+      config: configuration,
+      database: self.database,
+      directory: self.updatesDirectory!,
+      completionQueue: self.controllerQueue
+    )
+    launcher.launchUpdate(withSelectionPolicy: self.selectionPolicy()) { error, success in
+      if !success {
+        // reset controller's configuration to what it was before this request
+        self.config = self.previousUpdatesConfiguration!
+        errorBlock(error ?? NSError(
+          domain: DevLauncherAppController.ErrorDomain,
+          code: ErrorCode.updateLaunchFailed.rawValue,
+          userInfo: [NSLocalizedDescriptionKey: "Failed to launch update with an unknown error"]
+        ))
+        return
+      }
+
+      self.isStarted = true
+      self.launcher = launcher
+      successBlock(launcher.launchedUpdate?.manifest.rawManifestJSON())
+      self.runReaper()
+    }
+  }
+
+  private func runReaper() {
+    if let launchedUpdate = launcher?.launchedUpdate,
+      let config = self.config,
+      let updatesDirectory = updatesDirectory {
+      UpdatesReaper.reapUnusedUpdates(
+        withConfig: config,
+        database: database,
+        directory: updatesDirectory,
+        selectionPolicy: selectionPolicy(),
+        launchedUpdate: launchedUpdate
+      )
+    }
+  }
+
+  public func getConstantsForModule() -> UpdatesModuleConstants {
+    let embeddedUpdate: Update?
+    if isStarted {
+      embeddedUpdate = self.config.let { it in EmbeddedAppLoader.embeddedManifest(withConfig: it, database: self.database) }
+    } else {
+      embeddedUpdate = nil
+    }
+
+    return UpdatesModuleConstants(
+      launchedUpdate: launcher?.launchedUpdate,
+      embeddedUpdate: embeddedUpdate,
+      isEmergencyLaunch: isEmergencyLaunch,
+      isEnabled: true,
+      releaseChannel: self.config?.releaseChannel ?? "default",
+      isUsingEmbeddedAssets: isUsingEmbeddedAssets(),
+      runtimeVersion: self.config?.runtimeVersionRaw ?? "1",
+      checkOnLaunch: self.config?.checkOnLaunch ?? CheckAutomaticallyConfig.Always,
+      requestHeaders: self.config?.requestHeaders ?? [:],
+      assetFilesMap: assetFilesMap(),
+      isMissingRuntimeVersion: self.isMissingRuntimeVersion
+    )
+  }
+
+  public func requestRelaunch(success successBlockArg: @escaping () -> Void, error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void) {
+    errorBlockArg(NotAvailableInDevClientException())
+  }
+
+  public func checkForUpdate(success successBlockArg: @escaping (RemoteCheckResult) -> Void, error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void) {
+    errorBlockArg(NotAvailableInDevClientException())
+  }
+
+  public func fetchUpdate(success successBlockArg: @escaping (FetchUpdateResult) -> Void, error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void) {
+    errorBlockArg(NotAvailableInDevClientException())
+  }
+
+  public func getExtraParams(success successBlockArg: @escaping ([String: String]?) -> Void, error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void) {
+    errorBlockArg(NotAvailableInDevClientException())
+  }
+
+  public func setExtraParam(key: String, value: String?, success successBlockArg: @escaping () -> Void, error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void) {
+    errorBlockArg(NotAvailableInDevClientException())
+  }
+
+  public func getNativeStateMachineContext(success successBlockArg: @escaping (UpdatesStateContext) -> Void, error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void) {
+    successBlockArg(UpdatesStateContext())
+  }
+}
+
+// swiftlint:enable force_unwrapping
+// swiftlint:enable line_length
diff --git a/node_modules/expo-updates/ios/EXUpdates/DevLauncherController.swift b/node_modules/expo-updates/ios/EXUpdates/DevLauncherController.swift
deleted file mode 100644
index 634027b..0000000
--- a/node_modules/expo-updates/ios/EXUpdates/DevLauncherController.swift
+++ /dev/null
@@ -1,243 +0,0 @@
-//  Copyright © 2021 650 Industries. All rights reserved.
-
-// this class used a bunch of implicit non-null patterns for member variables. not worth refactoring to appease lint.
-// swiftlint:disable force_unwrapping
-
-import Foundation
-import EXUpdatesInterface
-
-/**
- * Main entry point to expo-updates in development builds with expo-dev-client. Singleton that still
- * makes use of AppController for keeping track of updates state, but provides capabilities
- * that are not usually exposed but that expo-dev-client needs (launching and downloading a specific
- * update by URL, allowing dynamic configuration, introspecting the database).
- *
- * Implements the EXUpdatesExternalInterface from the expo-updates-interface package. This allows
- * expo-dev-client to compile without needing expo-updates to be installed.
- */
-@objc(EXUpdatesDevLauncherController)
-@objcMembers
-public final class DevLauncherController: NSObject, UpdatesExternalInterface {
-  private static let ErrorDomain = "EXUpdatesDevLauncherController"
-
-  enum ErrorCode: Int {
-    case invalidUpdateURL = 1
-    case updateLaunchFailed = 4
-    case configFailed = 5
-  }
-
-  private var tempConfig: UpdatesConfig?
-
-  private weak var _bridge: AnyObject?
-  public weak var bridge: AnyObject? {
-    get {
-      return _bridge
-    }
-    set(value) {
-      _bridge = value
-      if let value = value as? RCTBridge {
-        AppController.sharedInstance.bridge = value
-      }
-    }
-  }
-
-  public static let sharedInstance = DevLauncherController()
-
-  override init() {}
-
-  public var launchAssetURL: URL? {
-    return AppController.sharedInstance.launchAssetUrl()
-  }
-
-  public func reset() {
-    let controller = AppController.sharedInstance
-    controller.launcher = nil
-    controller.isStarted = true
-  }
-
-  public func fetchUpdate(
-    withConfiguration configuration: [String: Any],
-    onManifest manifestBlock: @escaping UpdatesManifestBlock,
-    progress progressBlock: @escaping UpdatesProgressBlock,
-    success successBlock: @escaping UpdatesUpdateSuccessBlock,
-    error errorBlock: @escaping UpdatesErrorBlock
-  ) {
-    guard let updatesConfiguration = setup(configuration: configuration, error: errorBlock) else {
-      return
-    }
-
-    let controller = AppController.sharedInstance
-
-    // since controller is a singleton, save its config so we can reset to it if our request fails
-    tempConfig = controller.config
-
-    setDevelopmentSelectionPolicy()
-    controller.setConfigurationInternal(config: updatesConfiguration)
-
-    let loader = RemoteAppLoader(
-      config: updatesConfiguration,
-      database: controller.database,
-      directory: controller.updatesDirectory!,
-      launchedUpdate: nil,
-      completionQueue: controller.controllerQueue
-    )
-    loader.loadUpdate(
-      fromURL: updatesConfiguration.updateUrl!
-    ) { updateResponse in
-      if let updateDirective = updateResponse.directiveUpdateResponsePart?.updateDirective {
-        switch updateDirective {
-        case is NoUpdateAvailableUpdateDirective:
-          return false
-        case is RollBackToEmbeddedUpdateDirective:
-          return false
-        default:
-          NSException(name: .internalInconsistencyException, reason: "Unhandled update directive type").raise()
-          return false
-        }
-      }
-
-      guard let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
-        return false
-      }
-
-      return manifestBlock(update.manifest.rawManifestJSON())
-    } asset: { _, successfulAssetCount, failedAssetCount, totalAssetCount in
-      progressBlock(UInt(successfulAssetCount), UInt(failedAssetCount), UInt(totalAssetCount))
-    } success: { updateResponse in
-      guard let updateResponse = updateResponse,
-        let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
-        successBlock(nil)
-        return
-      }
-      self.launch(update: update, withConfiguration: updatesConfiguration, success: successBlock, error: errorBlock)
-    } error: { error in
-      // reset controller's configuration to what it was before this request
-      controller.setConfigurationInternal(config: self.tempConfig!)
-      errorBlock(error)
-    }
-  }
-
-  public func storedUpdateIds(
-    withConfiguration configuration: [String: Any],
-    success successBlock: @escaping UpdatesQuerySuccessBlock,
-    error errorBlock: @escaping UpdatesErrorBlock
-  ) {
-    guard setup(configuration: configuration, error: errorBlock) != nil else {
-      successBlock([])
-      return
-    }
-
-    AppLauncherWithDatabase.storedUpdateIds(
-      inDatabase: AppController.sharedInstance.database
-    ) { error, storedUpdateIds in
-      if let error = error {
-        errorBlock(error)
-      } else {
-        successBlock(storedUpdateIds!)
-      }
-    }
-  }
-
-  /**
-   Common initialization for both fetchUpdateWithConfiguration: and storedUpdateIdsWithConfiguration:
-   Sets up EXUpdatesAppController shared instance
-   Returns the updatesConfiguration
-   */
-  private func setup(configuration: [AnyHashable: Any], error errorBlock: UpdatesErrorBlock) -> UpdatesConfig? {
-    let controller = AppController.sharedInstance
-    var updatesConfiguration: UpdatesConfig
-    do {
-      updatesConfiguration = try UpdatesConfig.configWithExpoPlist(mergingOtherDictionary: configuration as? [String: Any] ?? [:])
-    } catch {
-      errorBlock(NSError(
-        domain: DevLauncherController.ErrorDomain,
-        code: ErrorCode.configFailed.rawValue,
-        userInfo: [
-          // swiftlint:disable:next line_length
-          NSLocalizedDescriptionKey: "Cannot load configuration from Expo.plist. Please ensure you've followed the setup and installation instructions for expo-updates to create Expo.plist and add it to your Xcode project."
-        ]
-      ))
-      return nil
-    }
-
-    guard updatesConfiguration.updateUrl != nil && updatesConfiguration.scopeKey != nil else {
-      errorBlock(NSError(
-        domain: DevLauncherController.ErrorDomain,
-        code: ErrorCode.invalidUpdateURL.rawValue,
-        userInfo: [
-          NSLocalizedDescriptionKey: "Failed to read stored updates: configuration object must include a valid update URL"
-        ]
-      ))
-      return nil
-    }
-
-    do {
-      try controller.initializeUpdatesDirectory()
-      try controller.initializeUpdatesDatabase()
-    } catch {
-      errorBlock(error)
-      return nil
-    }
-
-    return updatesConfiguration
-  }
-
-  private func setDevelopmentSelectionPolicy() {
-    let controller = AppController.sharedInstance
-    controller.resetSelectionPolicyToDefault()
-    let currentSelectionPolicy = controller.selectionPolicy()
-    controller.defaultSelectionPolicy = SelectionPolicy(
-      launcherSelectionPolicy: currentSelectionPolicy.launcherSelectionPolicy,
-      loaderSelectionPolicy: currentSelectionPolicy.loaderSelectionPolicy,
-      reaperSelectionPolicy: ReaperSelectionPolicyDevelopmentClient()
-    )
-    controller.resetSelectionPolicyToDefault()
-  }
-
-  private func launch(
-    update: Update,
-    withConfiguration configuration: UpdatesConfig,
-    success successBlock: @escaping UpdatesUpdateSuccessBlock,
-    error errorBlock: @escaping UpdatesErrorBlock
-  ) {
-    let controller = AppController.sharedInstance
-    // ensure that we launch the update we want, even if it isn't the latest one
-    let currentSelectionPolicy = controller.selectionPolicy()
-
-    // Calling `setNextSelectionPolicy` allows the Updates module's `reloadAsync` method to reload
-    // with a different (newer) update if one is downloaded, e.g. using `fetchUpdateAsync`. If we set
-    // the default selection policy here instead, the update we are launching here would keep being
-    // launched by `reloadAsync` even if a newer one is downloaded.
-    controller.setNextSelectionPolicy(SelectionPolicy(
-      launcherSelectionPolicy: LauncherSelectionPolicySingleUpdate(updateId: update.updateId),
-      loaderSelectionPolicy: currentSelectionPolicy.loaderSelectionPolicy,
-      reaperSelectionPolicy: currentSelectionPolicy.reaperSelectionPolicy
-    ))
-
-    let launcher = AppLauncherWithDatabase(
-      config: configuration,
-      database: controller.database,
-      directory: controller.updatesDirectory!,
-      completionQueue: controller.controllerQueue
-    )
-    launcher.launchUpdate(withSelectionPolicy: controller.selectionPolicy()) { error, success in
-      if !success {
-        // reset controller's configuration to what it was before this request
-        controller.setConfigurationInternal(config: self.tempConfig!)
-        errorBlock(error ?? NSError(
-          domain: DevLauncherController.ErrorDomain,
-          code: ErrorCode.updateLaunchFailed.rawValue,
-          userInfo: [NSLocalizedDescriptionKey: "Failed to launch update with an unknown error"]
-        ))
-        return
-      }
-
-      controller.isStarted = true
-      controller.launcher = launcher
-      successBlock(launcher.launchedUpdate?.manifest.rawManifestJSON())
-      controller.runReaper()
-    }
-  }
-}
-
-// swiftlint:enable force_unwrapping
diff --git a/node_modules/expo-updates/ios/EXUpdates/DisabledAppController.swift b/node_modules/expo-updates/ios/EXUpdates/DisabledAppController.swift
new file mode 100644
index 0000000..3e46b34
--- /dev/null
+++ b/node_modules/expo-updates/ios/EXUpdates/DisabledAppController.swift
@@ -0,0 +1,117 @@
+//  Copyright © 2019 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+
+/**
+ * Updates controller for applications that either disable updates explicitly or have an error
+ * during initialization. Errors that may occur include but are not limited to:
+ * - Disk access errors
+ * - Internal database initialization errors
+ * - Configuration errors (missing required configuration)
+ */
+public class DisabledAppController: InternalAppControllerInterface {
+  public private(set) var isStarted: Bool = false // this is always false for disabled controllers
+
+  public weak var bridge: AnyObject?
+
+  public weak var delegate: AppControllerDelegate?
+
+  internal private(set) var isEmergencyLaunch: Bool = false
+  private let initializationError: Error?
+  private var launcher: AppLauncher?
+  private let isMissingRuntimeVersion: Bool
+
+  public let updatesDirectory: URL? = nil // internal for E2E test
+
+  required init(error: Error?, isMissingRuntimeVersion: Bool) {
+    self.initializationError = error
+    self.isEmergencyLaunch = error != nil
+    self.isMissingRuntimeVersion = isMissingRuntimeVersion
+  }
+
+  public func start() {
+    let launcherNoDatabase = AppLauncherNoDatabase()
+    launcher = launcherNoDatabase
+    launcherNoDatabase.launchUpdate()
+
+    delegate.let { _ in
+      DispatchQueue.main.async { [weak self] in
+        if let strongSelf = self {
+          strongSelf.delegate?.appController(strongSelf, didStartWithSuccess: strongSelf.launchAssetUrl() != nil)
+        }
+      }
+    }
+
+    if let initializationError = self.initializationError {
+      ErrorRecovery.writeErrorOrExceptionToLog(initializationError)
+    }
+  }
+
+  private func launchedUpdate() -> Update? {
+    return launcher?.launchedUpdate
+  }
+
+  public func launchAssetUrl() -> URL? {
+    return launcher?.launchAssetUrl
+  }
+
+  public func getConstantsForModule() -> UpdatesModuleConstants {
+    return UpdatesModuleConstants(
+      launchedUpdate: launchedUpdate(),
+      embeddedUpdate: nil,
+      isEmergencyLaunch: self.isEmergencyLaunch,
+      isEnabled: false,
+      releaseChannel: UpdatesConfig.ReleaseChannelDefaultValue,
+      isUsingEmbeddedAssets: launcher?.isUsingEmbeddedAssets() ?? false,
+      runtimeVersion: nil,
+      checkOnLaunch: CheckAutomaticallyConfig.Never,
+      requestHeaders: [:],
+      assetFilesMap: launcher?.assetFilesMap,
+      isMissingRuntimeVersion: self.isMissingRuntimeVersion
+    )
+  }
+
+  public func requestRelaunch(
+    success successBlockArg: @escaping () -> Void,
+    error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void
+  ) {
+    errorBlockArg(UpdatesDisabledException())
+  }
+
+  public func checkForUpdate(
+    success successBlockArg: @escaping (RemoteCheckResult) -> Void,
+    error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void
+  ) {
+    errorBlockArg(UpdatesDisabledException())
+  }
+
+  public func fetchUpdate(
+    success successBlockArg: @escaping (FetchUpdateResult) -> Void,
+    error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void
+  ) {
+    errorBlockArg(UpdatesDisabledException())
+  }
+
+  public func getExtraParams(
+    success successBlockArg: @escaping ([String: String]?) -> Void,
+    error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void
+  ) {
+    errorBlockArg(UpdatesDisabledException())
+  }
+
+  public func setExtraParam(
+    key: String,
+    value: String?,
+    success successBlockArg: @escaping () -> Void,
+    error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void
+  ) {
+    errorBlockArg(UpdatesDisabledException())
+  }
+
+  public func getNativeStateMachineContext(
+    success successBlockArg: @escaping (UpdatesStateContext) -> Void,
+    error errorBlockArg: @escaping (ExpoModulesCore.Exception) -> Void
+  ) {
+    errorBlockArg(UpdatesDisabledException())
+  }
+}
diff --git a/node_modules/expo-updates/ios/EXUpdates/EXUpdatesService.h b/node_modules/expo-updates/ios/EXUpdates/EXUpdatesService.h
deleted file mode 100644
index 79006c9..0000000
--- a/node_modules/expo-updates/ios/EXUpdates/EXUpdatesService.h
+++ /dev/null
@@ -1,40 +0,0 @@
-// Copyright 2020-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXInternalModule.h>
-
-@class EXUpdatesConfig;
-@class EXUpdatesUpdate;
-@class EXUpdatesSelectionPolicy;
-@class EXUpdatesDatabase;
-
-NS_ASSUME_NONNULL_BEGIN
-
-typedef void (^EXUpdatesAppRelaunchCompletionBlock)(BOOL success);
-
-@protocol EXUpdatesModuleInterface
-
-@property (nonatomic, readonly, nullable) EXUpdatesConfig *config;
-@property (nonatomic, readonly) EXUpdatesDatabase *database;
-@property (nonatomic, readonly, nullable) EXUpdatesSelectionPolicy *selectionPolicy;
-@property (nonatomic, readonly) NSURL *directory;
-
-@property (nullable, nonatomic, readonly, strong) EXUpdatesUpdate *embeddedUpdate;
-@property (nullable, nonatomic, readonly, strong) EXUpdatesUpdate *launchedUpdate;
-@property (nullable, nonatomic, readonly, strong) NSDictionary *assetFilesMap;
-@property (nonatomic, readonly, assign) BOOL isEmbeddedLaunch;
-@property (nonatomic, readonly, assign) BOOL isUsingEmbeddedAssets;
-@property (nonatomic, readonly, assign) BOOL isStarted;
-@property (nonatomic, readonly, assign) BOOL isEmergencyLaunch;
-@property (nonatomic, readonly, assign) BOOL canRelaunch;
-@property (nonatomic, readonly, assign) BOOL canCheckForUpdateAndFetchUpdate;
-
-- (void)requestRelaunchWithCompletion:(EXUpdatesAppRelaunchCompletionBlock)completion;
-- (void)resetSelectionPolicy;
-
-@end
-
-@interface EXUpdatesService : NSObject <EXInternalModule, EXUpdatesModuleInterface>
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-updates/ios/EXUpdates/EXUpdatesService.m b/node_modules/expo-updates/ios/EXUpdates/EXUpdatesService.m
deleted file mode 100644
index d7bf5fe..0000000
--- a/node_modules/expo-updates/ios/EXUpdates/EXUpdatesService.m
+++ /dev/null
@@ -1,117 +0,0 @@
-// Copyright 2020-present 650 Industries. All rights reserved.
-
-#import <EXUpdates/EXUpdatesService.h>
-#import <ExpoModulesCore/EXUtilities.h>
-
-#if __has_include(<EXUpdates/EXUpdates-Swift.h>)
-#import <EXUpdates/EXUpdates-Swift.h>
-#else
-#import "EXUpdates-Swift.h"
-#endif
-
-NS_ASSUME_NONNULL_BEGIN
-
-/**
- * Internal module whose purpose is to connect EXUpdatesModule with the central updates entry point.
- * In most apps, this is EXUpdatesAppController.
- *
- * In other cases, this module can be overridden at runtime to redirect EXUpdatesModule to a
- * different entry point. This is the case in Expo Go, where this module is overridden by
- * EXUpdatesBinding in order to get data from EXAppLoaderExpoUpdates.
- */
-@implementation EXUpdatesService
-
-EX_REGISTER_MODULE();
-
-+ (const NSArray<Protocol *> *)exportedInterfaces
-{
-#if SUPPRESS_EXPO_UPDATES_SERVICE // used in Expo Go
-  return @[];
-#endif
-  return @[@protocol(EXUpdatesModuleInterface)];
-}
-
-- (nullable EXUpdatesConfig *)config
-{
-#if SUPPRESS_EXPO_UPDATES_SERVICE // used in Expo Go
-  return nil;
-#endif
-  return EXUpdatesAppController.sharedInstance.config;
-}
-
-- (EXUpdatesDatabase *)database
-{
-  return EXUpdatesAppController.sharedInstance.database;
-}
-
-- (nullable EXUpdatesSelectionPolicy *)selectionPolicy
-{
-  return EXUpdatesAppController.sharedInstance.selectionPolicy;
-}
-
-- (NSURL *)directory
-{
-  return EXUpdatesAppController.sharedInstance.updatesDirectory;
-}
-
-- (nullable EXUpdatesUpdate *)embeddedUpdate
-{
-  return [EXUpdatesEmbeddedAppLoader embeddedManifestWithConfig:self.config database:self.database];
-}
-
-- (nullable EXUpdatesUpdate *)launchedUpdate
-{
-  return EXUpdatesAppController.sharedInstance.launchedUpdate;
-}
-
-- (nullable NSDictionary *)assetFilesMap
-{
-  return EXUpdatesAppController.sharedInstance.assetFilesMap;
-}
-
-- (BOOL)isUsingEmbeddedAssets
-{
-  return EXUpdatesAppController.sharedInstance.isUsingEmbeddedAssets;
-}
-
-- (BOOL)isEmbeddedLaunch
-{
-  // True if the embedded update and its ID are not nil, and match
-  // the ID of the launched update
-  return [[self embeddedUpdate] updateId] != nil &&
-  [[[self embeddedUpdate] updateId] isEqual:[[self launchedUpdate] updateId]];
-}
-
-- (BOOL)isStarted
-{
-  return EXUpdatesAppController.sharedInstance.isStarted;
-}
-
-- (BOOL)isEmergencyLaunch
-{
-  return EXUpdatesAppController.sharedInstance.isEmergencyLaunch;
-}
-
-- (BOOL)canRelaunch
-{
-  return EXUpdatesAppController.sharedInstance.isStarted;
-}
-
-- (BOOL)canCheckForUpdateAndFetchUpdate
-{
-  return YES;
-}
-
-- (void)requestRelaunchWithCompletion:(EXUpdatesAppRelaunchCompletionBlock)completion
-{
-  return [EXUpdatesAppController.sharedInstance requestRelaunchWithCompletion:completion];
-}
-
-- (void)resetSelectionPolicy
-{
-  return [EXUpdatesAppController.sharedInstance resetSelectionPolicyToDefault];
-}
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-updates/ios/EXUpdates/EnabledAppController.swift b/node_modules/expo-updates/ios/EXUpdates/EnabledAppController.swift
new file mode 100644
index 0000000..1bebcae
--- /dev/null
+++ b/node_modules/expo-updates/ios/EXUpdates/EnabledAppController.swift
@@ -0,0 +1,789 @@
+//  Copyright © 2019 650 Industries. All rights reserved.
+
+// swiftlint:disable force_unwrapping
+// swiftlint:disable closure_body_length
+
+import SwiftUI
+import ExpoModulesCore
+
+/**
+ * Updates controller for applications that have updates enabled and properly-configured.
+ */
+public class EnabledAppController: AppLoaderTaskDelegate, AppLoaderTaskSwiftDelegate, 
+  ErrorRecoveryDelegate, UpdatesStateChangeDelegate, InternalAppControllerInterface {
+
+  private static let ErrorDomain = "EXUpdatesAppController"
+  private static let EXUpdatesEventName = "Expo.nativeUpdatesEvent"
+  private static let EXUpdatesStateChangeEventName = "Expo.nativeUpdatesStateChangeEvent"
+
+  // Events for the legacy UpdateEvent JS listener
+  public static let UpdateAvailableEventName = "updateAvailable"
+  public static let NoUpdateAvailableEventName = "noUpdateAvailable"
+  public static let ErrorEventName = "error"
+
+  public weak var delegate: AppControllerDelegate?
+  public weak var bridge: AnyObject?
+
+  public func launchAssetUrl() -> URL? {
+    return launcher?.launchAssetUrl
+  }
+
+  public func assetFilesMap() -> [String: Any]? {
+    return launcher?.assetFilesMap
+  }
+
+  public func isUsingEmbeddedAssets() -> Bool {
+    guard let launcher = launcher else {
+      return true
+    }
+    return launcher.isUsingEmbeddedAssets()
+  }
+
+  internal let config: UpdatesConfig
+  private let database: UpdatesDatabase
+
+  private var launcher: AppLauncher?
+  private let errorRecovery = ErrorRecovery()
+  public let updatesDirectory: URL? // internal for E2E test
+  private let updatesDirectoryInternal: URL
+  private let controllerQueue = DispatchQueue(label: "expo.controller.ControllerQueue")
+  public private(set) var isStarted = false
+
+  private var eventsToSendToJS: [[String: Any?]] = []
+
+  private let stateMachine = UpdatesStateMachine()
+
+  private var loaderTask: AppLoaderTask?
+  private var candidateLauncher: AppLauncher?
+
+  private var isEmergencyLaunch: Bool = false
+
+  private let selectionPolicy: SelectionPolicy
+
+  internal var remoteLoadStatus: RemoteLoadStatus = .Idle
+
+  private let logger = UpdatesLogger()
+
+  required init(config: UpdatesConfig, database: UpdatesDatabase, updatesDirectory: URL) {
+    self.config = config
+    self.database = database
+    self.updatesDirectoryInternal = updatesDirectory
+    self.updatesDirectory = updatesDirectory
+    self.selectionPolicy = SelectionPolicyFactory.filterAwarePolicy(
+      withRuntimeVersion: self.config.runtimeVersionRealized
+    )
+    self.logger.info(message: "AppController sharedInstance created")
+
+    self.errorRecovery.delegate = self
+    self.stateMachine.changeEventDelegate = self
+    self.stateMachine.reset()
+  }
+
+  public func start() {
+    precondition(!isStarted, "AppController:start should only be called once per instance")
+
+    isStarted = true
+
+    purgeUpdatesLogsOlderThanOneDay()
+
+    UpdatesBuildData.ensureBuildDataIsConsistentAsync(database: database, config: config)
+
+    errorRecovery.startMonitoring()
+
+    loaderTask = AppLoaderTask(
+      withConfig: config,
+      database: database,
+      directory: updatesDirectoryInternal,
+      selectionPolicy: selectionPolicy,
+      delegateQueue: controllerQueue
+    )
+    loaderTask!.delegate = self
+    loaderTask!.swiftDelegate = self
+    loaderTask!.start()
+  }
+
+  /**
+   Starts the update process to launch a previously-loaded update and (if configured to do so)
+   check for a new update from the server. This method should be called as early as possible in
+   the application's lifecycle.
+
+   Note that iOS may stop showing the app's splash screen in case the update is taking a while
+   to load. This method will attempt to find `LaunchScreen.xib` and load it into view while the
+   update is loading.
+   */
+  public func startAndShowLaunchScreen(_ window: UIWindow) {
+    var view: UIView?
+    let mainBundle = Bundle.main
+    let launchScreen = mainBundle.object(forInfoDictionaryKey: "UILaunchStoryboardName") as? String ?? "LaunchScreen"
+
+    if mainBundle.path(forResource: launchScreen, ofType: "nib") != nil {
+      let views = mainBundle.loadNibNamed(launchScreen, owner: self)
+      view = views?.first as? UIView
+      view?.autoresizingMask = [.flexibleWidth, .flexibleHeight]
+    } else if mainBundle.path(forResource: launchScreen, ofType: "storyboard") != nil ||
+      mainBundle.path(forResource: launchScreen, ofType: "storyboardc") != nil {
+      let launchScreenStoryboard = UIStoryboard(name: launchScreen, bundle: nil)
+      let viewController = launchScreenStoryboard.instantiateInitialViewController()
+      view = viewController?.view
+      viewController?.view = nil
+    } else {
+      NSLog("Launch screen could not be loaded from a .xib or .storyboard. Unexpected loading behavior may occur.")
+      view = UIView()
+      view?.backgroundColor = .white
+    }
+
+    if window.rootViewController == nil {
+      window.rootViewController = UIViewController()
+    }
+    window.rootViewController!.view = view
+    window.makeKeyAndVisible()
+
+    start()
+  }
+
+  public func requestRelaunch(
+    success successBlockArg: @escaping () -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  ) {
+    stateMachine.processEvent(UpdatesStateEventRestart())
+    let launcherWithDatabase = AppLauncherWithDatabase(
+      config: config,
+      database: database,
+      directory: updatesDirectoryInternal,
+      completionQueue: controllerQueue
+    )
+    candidateLauncher = launcherWithDatabase
+    launcherWithDatabase.launchUpdate(withSelectionPolicy: selectionPolicy) { error, success in
+      if success {
+        self.launcher = self.candidateLauncher
+        successBlockArg()
+        self.errorRecovery.startMonitoring()
+        RCTReloadCommandSetBundleURL(self.launcher!.launchAssetUrl)
+        RCTTriggerReloadCommandListeners("Requested by JavaScript - Updates.reloadAsync()")
+        self.runReaper()
+        // Reset the state machine
+        self.stateMachine.reset()
+      } else {
+        NSLog("Failed to relaunch: %@", error!.localizedDescription)
+        errorBlockArg(UpdatesReloadException())
+      }
+    }
+  }
+
+  public func launchedUpdate() -> Update? {
+    return launcher?.launchedUpdate
+  }
+
+  // MARK: - AppLoaderTaskDelegate
+
+  public func appLoaderTask(_: AppLoaderTask, didLoadCachedUpdate update: Update) -> Bool {
+    return true
+  }
+
+  public func appLoaderTaskDidStartCheckingForRemoteUpdate(_: AppLoaderTask) {
+    stateMachine.processEvent(UpdatesStateEventCheck())
+  }
+
+  public func appLoaderTask(_: AppLoaderTask, didFinishCheckingForRemoteUpdateWithRemoteCheckResult remoteCheckResult: RemoteCheckResult) {
+    let event: UpdatesStateEvent
+    switch remoteCheckResult {
+    case .noUpdateAvailable: // Not using reason to update state yet
+      event = UpdatesStateEventCheckComplete()
+    case .updateAvailable(let manifest):
+      event = UpdatesStateEventCheckCompleteWithUpdate(manifest: manifest)
+    case .rollBackToEmbedded(let commitTime):
+      event = UpdatesStateEventCheckCompleteWithRollback(rollbackCommitTime: commitTime)
+    case .error(let error):
+      event = UpdatesStateEventCheckError(message: error.localizedDescription)
+    }
+    stateMachine.processEvent(event)
+  }
+
+  public func appLoaderTask(_: AppLoaderTask, didStartLoadingUpdate update: Update?) {
+    logger.info(message: "AppController appLoaderTask didStartLoadingUpdate", code: .none, updateId: update?.loggingId(), assetId: nil)
+    stateMachine.processEvent(UpdatesStateEventDownload())
+  }
+
+  public func appLoaderTask(_: AppLoaderTask, didFinishWithLauncher launcher: AppLauncher, isUpToDate: Bool) {
+    let logMessage = String(
+      format: "AppController appLoaderTask didFinishWithLauncher, isUpToDate=%d, remoteLoadStatus=%ld",
+      isUpToDate,
+      remoteLoadStatus.rawValue
+    )
+    logger.info(message: logMessage)
+
+    // if isUpToDate is false, that means a remote update is still loading in the background (this
+    // method was called with a cached update because the timer ran out) so don't update the status
+
+    if remoteLoadStatus == .Loading && isUpToDate {
+      remoteLoadStatus = .Idle
+    }
+
+    self.launcher = launcher
+
+    delegate.let { it in
+      UpdatesUtils.runBlockOnMainThread {
+        it.appController(self, didStartWithSuccess: true)
+        self.sendQueuedEventsToBridge()
+      }
+    }
+  }
+
+  public func appLoaderTask(_: AppLoaderTask, didLoadAsset asset: UpdateAsset, successfulAssetCount: Int, failedAssetCount: Int, totalAssetCount: Int) {
+    let body = [
+      "assetInfo": [
+        "name": asset.filename,
+        "successfulAssetCount": successfulAssetCount,
+        "failedAssetCount": failedAssetCount,
+        "totalAssetCount": totalAssetCount
+      ] as [String: Any]
+    ]
+    logger.info(
+      message: "AppController appLoaderTask didLoadAsset: \(body)",
+      code: .none,
+      updateId: nil,
+      assetId: asset.contentHash
+    )
+  }
+
+  public func appLoaderTask(_: AppLoaderTask, didFinishWithError error: Error) {
+    let logMessage = String(format: "AppController appLoaderTask didFinishWithError: %@", error.localizedDescription)
+    logger.error(message: logMessage, code: .updateFailedToLoad)
+    stateMachine.processEvent(UpdatesStateEventDownloadError(message: error.localizedDescription))
+    // Send legacy UpdateEvents to JS
+    sendLegacyUpdateEventToBridge(EnabledAppController.ErrorEventName, body: [
+      "message": error.localizedDescription
+    ])
+    emergencyLaunch(fatalError: error as NSError)
+  }
+
+  public func appLoaderTask(
+    _: AppLoaderTask,
+    didFinishBackgroundUpdateWithStatus status: BackgroundUpdateStatus,
+    update: Update?,
+    error: Error?
+  ) {
+    switch status {
+    case .error:
+      remoteLoadStatus = .Idle
+      guard let error = error else {
+        preconditionFailure("Background update with error status must have a nonnull error object")
+      }
+      logger.error(
+        message: "AppController appLoaderTask didFinishBackgroundUpdateWithStatus=Error",
+        code: .updateFailedToLoad,
+        updateId: update?.loggingId(),
+        assetId: nil
+      )
+      // Since errors can happen through a number of paths, we do these checks
+      // to make sure the state machine is valid
+      if stateMachine.state == .checking {
+        stateMachine.processEvent(UpdatesStateEventCheckError(message: error.localizedDescription))
+      } else if stateMachine.state == .downloading {
+        // .downloading
+        stateMachine.processEvent(UpdatesStateEventDownloadError(message: error.localizedDescription))
+      }
+      // Send UpdateEvents to JS
+      sendLegacyUpdateEventToBridge(EnabledAppController.ErrorEventName, body: [
+        "message": error.localizedDescription
+      ])
+    case .updateAvailable:
+      remoteLoadStatus = .NewUpdateLoaded
+      guard let update = update else {
+        preconditionFailure("Background update with error status must have a nonnull update object")
+      }
+      logger.info(
+        message: "AppController appLoaderTask didFinishBackgroundUpdateWithStatus=NewUpdateLoaded",
+        code: .none,
+        updateId: update.loggingId(),
+        assetId: nil
+      )
+      stateMachine.processEvent(UpdatesStateEventDownloadCompleteWithUpdate(manifest: update.manifest.rawManifestJSON()))
+      // Send UpdateEvents to JS
+      sendLegacyUpdateEventToBridge(EnabledAppController.UpdateAvailableEventName, body: [
+        "manifest": update.manifest.rawManifestJSON()
+      ])
+    case .noUpdateAvailable:
+      remoteLoadStatus = .Idle
+      logger.info(
+        message: "AppController appLoaderTask didFinishBackgroundUpdateWithStatus=NoUpdateAvailable",
+        code: .noUpdatesAvailable,
+        updateId: update?.loggingId(),
+        assetId: nil
+      )
+      // TODO: handle rollbacks properly, but this works for now
+      if stateMachine.state == .downloading {
+        stateMachine.processEvent(UpdatesStateEventDownloadComplete())
+      }
+      // Otherwise, we don't need to call the state machine here, it already transitioned to .checkCompleteUnavailable
+      // Send UpdateEvents to JS
+      sendLegacyUpdateEventToBridge(EnabledAppController.NoUpdateAvailableEventName, body: [:])
+    }
+
+    errorRecovery.notify(newRemoteLoadStatus: remoteLoadStatus)
+  }
+
+  // MARK: - Internal
+
+  private func purgeUpdatesLogsOlderThanOneDay() {
+    UpdatesUtils.purgeUpdatesLogsOlderThanOneDay()
+  }
+
+  internal func runReaper() {
+    if let launchedUpdate = launcher?.launchedUpdate {
+      UpdatesReaper.reapUnusedUpdates(
+        withConfig: config,
+        database: database,
+        directory: updatesDirectoryInternal,
+        selectionPolicy: selectionPolicy,
+        launchedUpdate: launchedUpdate
+      )
+    }
+  }
+
+  private func emergencyLaunch(fatalError error: NSError) {
+    isEmergencyLaunch = true
+
+    let launcherNoDatabase = AppLauncherNoDatabase()
+    launcher = launcherNoDatabase
+    launcherNoDatabase.launchUpdate()
+
+    delegate.let { _ in
+      DispatchQueue.main.async { [weak self] in
+        if let strongSelf = self {
+          strongSelf.delegate?.appController(strongSelf, didStartWithSuccess: strongSelf.launchAssetUrl() != nil)
+          strongSelf.sendQueuedEventsToBridge()
+        }
+      }
+    }
+
+    ErrorRecovery.writeErrorOrExceptionToLog(error)
+  }
+
+  // MARK: - Send events to JS
+
+  internal func sendLegacyUpdateEventToBridge(_ eventType: String, body: [String: Any] ) {
+    logger.info(message: "sendLegacyUpdateEventToBridge(): type = \(eventType)")
+    sendEventToBridge(EnabledAppController.EXUpdatesEventName, eventType, body: body)
+  }
+
+  internal func sendUpdateStateChangeEventToBridge(_ eventType: UpdatesStateEventType, body: [String: Any?]) {
+    logger.info(message: "sendUpdateStateChangeEventToBridge(): type = \(eventType)")
+    sendEventToBridge(EnabledAppController.EXUpdatesStateChangeEventName, "\(eventType)", body: body)
+  }
+
+  private func sendEventToBridge(_ eventName: String, _ eventType: String, body: [String: Any?]) {
+    var mutableBody = body
+    mutableBody["type"] = eventType
+
+    guard let bridge = bridge else {
+      eventsToSendToJS.append([
+        "eventName": eventName,
+        "mutableBody": mutableBody
+      ])
+      logger.warn(message: "EXUpdates: Could not emit event: name = \(eventName), type = \(eventType). Event will be emitted when the bridge is available", code: .jsRuntimeError)
+      return
+    }
+    logger.debug(message: "sendEventToBridge: \(eventName), \(mutableBody)")
+    bridge.enqueueJSCall("RCTDeviceEventEmitter.emit", args: [eventName, mutableBody])
+  }
+
+  internal func sendQueuedEventsToBridge() {
+    guard let bridge = bridge else {
+      return
+    }
+    eventsToSendToJS.forEach { event in
+      guard let eventName = event["eventName"] as? String,
+        let mutableBody = event["mutableBody"] as? [String: Any?] else {
+        return
+      }
+      logger.debug(message: "sendEventToBridge: \(eventName), \(mutableBody)")
+      bridge.enqueueJSCall("RCTDeviceEventEmitter.emit", args: [eventName, mutableBody])
+    }
+    eventsToSendToJS = []
+  }
+
+  // MARK: - ErrorRecoveryDelegate
+
+  public func relaunch(completion: @escaping (Error?, Bool) -> Void) {
+    let launcher = AppLauncherWithDatabase(
+      config: config,
+      database: database,
+      directory: updatesDirectoryInternal,
+      completionQueue: controllerQueue
+    )
+    candidateLauncher = launcher
+    launcher.launchUpdate(withSelectionPolicy: selectionPolicy) { error, success in
+      if success {
+        self.launcher = self.candidateLauncher
+        self.errorRecovery.startMonitoring()
+        RCTReloadCommandSetBundleURL(launcher.launchAssetUrl)
+        RCTTriggerReloadCommandListeners("Relaunch after fatal error")
+        completion(nil, true)
+      } else {
+        completion(error, false)
+      }
+    }
+  }
+
+  public func loadRemoteUpdate() {
+    if let loaderTask = loaderTask, loaderTask.isRunning {
+      return
+    }
+
+    remoteLoadStatus = .Loading
+
+    let remoteAppLoader = RemoteAppLoader(
+      config: config,
+      database: database,
+      directory: updatesDirectoryInternal,
+      launchedUpdate: launchedUpdate(),
+      completionQueue: controllerQueue
+    )
+    remoteAppLoader.loadUpdate(
+      fromURL: config.updateUrl
+    ) { updateResponse in
+      if let updateDirective = updateResponse.directiveUpdateResponsePart?.updateDirective {
+        switch updateDirective {
+        case is NoUpdateAvailableUpdateDirective:
+          return false
+        case is RollBackToEmbeddedUpdateDirective:
+          return false
+        default:
+          NSException(name: .internalInconsistencyException, reason: "Unhandled update directive type").raise()
+          return false
+        }
+      }
+
+      guard let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
+        return false
+      }
+
+      return self.selectionPolicy.shouldLoadNewUpdate(
+        update,
+        withLaunchedUpdate: self.launchedUpdate(),
+        filters: updateResponse.responseHeaderData?.manifestFilters
+      )
+    } asset: { _, _, _, _ in
+      // do nothing for now
+    } success: { updateResponse in
+      self.remoteLoadStatus = updateResponse != nil ? .NewUpdateLoaded : .Idle
+      self.errorRecovery.notify(newRemoteLoadStatus: self.remoteLoadStatus)
+    } error: { error in
+      self.logger.error(message: "AppController loadRemoteUpdate error: \(error.localizedDescription)", code: .updateFailedToLoad)
+      self.remoteLoadStatus = .Idle
+      self.errorRecovery.notify(newRemoteLoadStatus: self.remoteLoadStatus)
+    }
+  }
+
+  public func markFailedLaunchForLaunchedUpdate() {
+    if isEmergencyLaunch {
+      return
+    }
+
+    database.databaseQueue.async {
+      guard let launchedUpdate = self.launchedUpdate() else {
+        return
+      }
+
+      self.logger.error(
+        message: "AppController markFailedLaunchForUpdate",
+        code: .unknown,
+        updateId: launchedUpdate.loggingId(),
+        assetId: nil
+      )
+      do {
+        try self.database.incrementFailedLaunchCountForUpdate(launchedUpdate)
+      } catch {
+        NSLog("Unable to mark update as failed in the local DB: %@", error.localizedDescription)
+      }
+    }
+  }
+
+  public func markSuccessfulLaunchForLaunchedUpdate() {
+    if isEmergencyLaunch {
+      return
+    }
+
+    database.databaseQueue.async {
+      guard let launchedUpdate = self.launchedUpdate() else {
+        return
+      }
+
+      do {
+        try self.database.incrementSuccessfulLaunchCountForUpdate(launchedUpdate)
+      } catch {
+        NSLog("Failed to increment successful launch count for update: %@", error.localizedDescription)
+      }
+    }
+  }
+
+  public func throwException(_ exception: NSException) {
+    exception.raise()
+  }
+
+  // MARK: - JS API
+
+  public func getConstantsForModule() -> UpdatesModuleConstants {
+    return UpdatesModuleConstants(
+      launchedUpdate: launchedUpdate(),
+      embeddedUpdate: getEmbeddedUpdate(),
+      isEmergencyLaunch: isEmergencyLaunch,
+      isEnabled: true,
+      releaseChannel: self.config.releaseChannel,
+      isUsingEmbeddedAssets: isUsingEmbeddedAssets(),
+      runtimeVersion: self.config.runtimeVersionRaw ?? "",
+      checkOnLaunch: self.config.checkOnLaunch,
+      requestHeaders: self.config.requestHeaders,
+      assetFilesMap: assetFilesMap(),
+      isMissingRuntimeVersion: false
+    )
+  }
+
+  public func checkForUpdate(
+    success successBlockArg: @escaping (_ remoteCheckResult: RemoteCheckResult) -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  ) {
+    stateMachine.processEvent(UpdatesStateEventCheck())
+
+    database.databaseQueue.async {
+      let embeddedUpdate = EmbeddedAppLoader.embeddedManifest(withConfig: self.config, database: self.database)
+      let extraHeaders = FileDownloader.extraHeadersForRemoteUpdateRequest(
+        withDatabase: self.database,
+        config: self.config,
+        launchedUpdate: self.launchedUpdate(),
+        embeddedUpdate: embeddedUpdate
+      )
+
+      FileDownloader(config: self.config).downloadRemoteUpdate(
+        fromURL: self.config.updateUrl,
+        withDatabase: self.database,
+        extraHeaders: extraHeaders) { updateResponse in
+          let launchedUpdate = self.launchedUpdate()
+          let manifestFilters = updateResponse.responseHeaderData?.manifestFilters
+
+          if let updateDirective = updateResponse.directiveUpdateResponsePart?.updateDirective {
+            switch updateDirective {
+            case is NoUpdateAvailableUpdateDirective:
+              successBlockArg(RemoteCheckResult.noUpdateAvailable(reason: RemoteCheckResultNotAvailableReason.noUpdateAvailableOnServer))
+              self.stateMachine.processEvent(UpdatesStateEventCheckComplete())
+              return
+            case let rollBackUpdateDirective as RollBackToEmbeddedUpdateDirective:
+              if !self.config.hasEmbeddedUpdate {
+                successBlockArg(RemoteCheckResult.noUpdateAvailable(reason: RemoteCheckResultNotAvailableReason.rollbackNoEmbedded))
+                self.stateMachine.processEvent(UpdatesStateEventCheckComplete())
+                return
+              }
+
+              guard let embeddedUpdate = embeddedUpdate else {
+                successBlockArg(RemoteCheckResult.noUpdateAvailable(reason: RemoteCheckResultNotAvailableReason.rollbackNoEmbedded))
+                self.stateMachine.processEvent(UpdatesStateEventCheckComplete())
+                return
+              }
+
+              if !self.selectionPolicy.shouldLoadRollBackToEmbeddedDirective(
+                rollBackUpdateDirective,
+                withEmbeddedUpdate: embeddedUpdate,
+                launchedUpdate: launchedUpdate,
+                filters: manifestFilters
+              ) {
+                successBlockArg(RemoteCheckResult.noUpdateAvailable(reason: RemoteCheckResultNotAvailableReason.rollbackRejectedBySelectionPolicy))
+                self.stateMachine.processEvent(UpdatesStateEventCheckComplete())
+                return
+              }
+
+              successBlockArg(RemoteCheckResult.rollBackToEmbedded(commitTime: rollBackUpdateDirective.commitTime))
+              self.stateMachine.processEvent(
+                UpdatesStateEventCheckCompleteWithRollback(rollbackCommitTime: rollBackUpdateDirective.commitTime)
+              )
+              return
+            default:
+              let error = UpdatesUnsupportedDirectiveException()
+              self.stateMachine.processEvent(UpdatesStateEventCheckError(message: error.localizedDescription))
+              successBlockArg(RemoteCheckResult.error(error: error))
+              return
+            }
+          }
+
+          guard let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
+            successBlockArg(RemoteCheckResult.noUpdateAvailable(reason: RemoteCheckResultNotAvailableReason.noUpdateAvailableOnServer))
+            self.stateMachine.processEvent(UpdatesStateEventCheckComplete())
+            return
+          }
+
+          var shouldLaunch = false
+          var failedPreviously = false
+          if self.selectionPolicy.shouldLoadNewUpdate(
+            update,
+            withLaunchedUpdate: launchedUpdate,
+            filters: manifestFilters
+          ) {
+            // If "update" has failed to launch previously, then
+            // "launchedUpdate" will be an earlier update, and the test above
+            // will return true (incorrectly).
+            // We check to see if the new update is already in the DB, and if so,
+            // only allow the update if it has had no launch failures.
+            shouldLaunch = true
+            self.database.databaseQueue.sync {
+              do {
+                let storedUpdate = try self.database.update(withId: update.updateId, config: self.config)
+                if let storedUpdate = storedUpdate {
+                  shouldLaunch = storedUpdate.failedLaunchCount == 0 || storedUpdate.successfulLaunchCount > 0
+                  failedPreviously = !shouldLaunch
+                  self.logger.info(message: "Stored update found: ID = \(update.updateId), failureCount = \(storedUpdate.failedLaunchCount)")
+                }
+              } catch {}
+            }
+          }
+          if shouldLaunch {
+            successBlockArg(RemoteCheckResult.updateAvailable(manifest: update.manifest.rawManifestJSON()))
+            self.stateMachine.processEvent(UpdatesStateEventCheckCompleteWithUpdate(manifest: update.manifest.rawManifestJSON()))
+          } else {
+            let reason = failedPreviously ?
+              RemoteCheckResultNotAvailableReason.updatePreviouslyFailed :
+              RemoteCheckResultNotAvailableReason.updateRejectedBySelectionPolicy
+            successBlockArg(RemoteCheckResult.noUpdateAvailable(reason: reason))
+            self.stateMachine.processEvent(UpdatesStateEventCheckComplete())
+          }
+        } errorBlock: { error in
+          self.stateMachine.processEvent(UpdatesStateEventCheckError(message: error.localizedDescription))
+          successBlockArg(RemoteCheckResult.error(error: error))
+          return
+      }
+    }
+  }
+
+  public func fetchUpdate(
+    success successBlockArg: @escaping (_ fetchUpdateResult: FetchUpdateResult) -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  ) {
+    self.stateMachine.processEvent(UpdatesStateEventDownload())
+    let remoteAppLoader = RemoteAppLoader(
+      config: self.config,
+      database: self.database,
+      directory: self.updatesDirectoryInternal,
+      launchedUpdate: self.launchedUpdate(),
+      completionQueue: controllerQueue
+    )
+    remoteAppLoader.loadUpdate(
+      fromURL: self.config.updateUrl
+    ) { updateResponse in
+      if let updateDirective = updateResponse.directiveUpdateResponsePart?.updateDirective {
+        switch updateDirective {
+        case is NoUpdateAvailableUpdateDirective:
+          return false
+        case is RollBackToEmbeddedUpdateDirective:
+          return true
+        default:
+          NSException(name: .internalInconsistencyException, reason: "Unhandled update directive type").raise()
+          return false
+        }
+      }
+
+      guard let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
+        return false
+      }
+
+      return self.selectionPolicy.shouldLoadNewUpdate(
+        update,
+        withLaunchedUpdate: self.launchedUpdate(),
+        filters: updateResponse.responseHeaderData?.manifestFilters
+      )
+    } asset: { asset, successfulAssetCount, failedAssetCount, totalAssetCount in
+      let body = [
+        "assetInfo": [
+          "assetName": asset.filename,
+          "successfulAssetCount": successfulAssetCount,
+          "failedAssetCount": failedAssetCount,
+          "totalAssetCount": totalAssetCount
+        ] as [String: Any]
+      ] as [String: Any]
+      self.logger.info(
+        message: "fetchUpdateAsync didLoadAsset: \(body)",
+        code: .none,
+        updateId: nil,
+        assetId: asset.contentHash
+      )
+    } success: { updateResponse in
+      RemoteAppLoader.processSuccessLoaderResult(
+        config: self.config,
+        database: self.database,
+        selectionPolicy: self.selectionPolicy,
+        launchedUpdate: self.launchedUpdate(),
+        directory: self.updatesDirectoryInternal,
+        loaderTaskQueue: DispatchQueue(label: "expo.loader.LoaderTaskQueue"),
+        updateResponse: updateResponse,
+        priorError: nil
+      ) { updateToLaunch, error, didRollBackToEmbedded in
+        if let error = error {
+          self.stateMachine.processEvent(UpdatesStateEventDownloadError(message: error.localizedDescription))
+          successBlockArg(FetchUpdateResult.error(error: error))
+          return
+        }
+
+        if didRollBackToEmbedded {
+          successBlockArg(FetchUpdateResult.rollBackToEmbedded)
+          self.stateMachine.processEvent(UpdatesStateEventDownloadCompleteWithRollback())
+          return
+        }
+
+        if let update = updateToLaunch {
+          successBlockArg(FetchUpdateResult.success(manifest: update.manifest.rawManifestJSON()))
+          self.stateMachine.processEvent(UpdatesStateEventDownloadCompleteWithUpdate(manifest: update.manifest.rawManifestJSON()))
+          return
+        }
+
+        successBlockArg(FetchUpdateResult.failure)
+        self.stateMachine.processEvent(UpdatesStateEventDownloadComplete())
+        return
+      }
+    } error: { error in
+      self.stateMachine.processEvent(UpdatesStateEventDownloadError(message: error.localizedDescription))
+      successBlockArg(FetchUpdateResult.error(error: error))
+      return
+    }
+  }
+
+  public func getNativeStateMachineContext(
+    success successBlockArg: @escaping (_ stateMachineContext: UpdatesStateContext) -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  ) {
+    successBlockArg(self.stateMachine.context)
+  }
+
+  public func getExtraParams(
+    success successBlockArg: @escaping (_ extraParams: [String: String]?) -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  ) {
+    self.database.databaseQueue.async {
+      do {
+        successBlockArg(try self.database.extraParams(withScopeKey: self.config.scopeKey))
+      } catch {
+        errorBlockArg(UnexpectedException(error))
+      }
+    }
+  }
+
+  public func setExtraParam(
+    key: String,
+    value: String?,
+    success successBlockArg: @escaping () -> Void,
+    error errorBlockArg: @escaping (_ error: Exception) -> Void
+  ) {
+    self.database.databaseQueue.async {
+      do {
+        try self.database.setExtraParam(key: key, value: value, withScopeKey: self.config.scopeKey)
+        successBlockArg()
+      } catch {
+        errorBlockArg(UnexpectedException(error))
+      }
+    }
+  }
+
+  public func getEmbeddedUpdate() -> Update? {
+    return EmbeddedAppLoader.embeddedManifest(withConfig: self.config, database: self.database)
+  }
+}
+
+// swiftlint:enable closure_body_length
+// swiftlint:enable force_unwrapping
diff --git a/node_modules/expo-updates/ios/EXUpdates/ErrorRecovery.swift b/node_modules/expo-updates/ios/EXUpdates/ErrorRecovery.swift
index c242f80..2744d8c 100644
--- a/node_modules/expo-updates/ios/EXUpdates/ErrorRecovery.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/ErrorRecovery.swift
@@ -21,19 +21,18 @@ public enum RemoteLoadStatus: Int {
 }
 // swiftlint:enable identifier_name
 
-@objc(EXUpdatesErrorRecoveryDelegate)
-public protocol ErrorRecoveryDelegate: AnyObject {
-  @objc var config: UpdatesConfig { get }
-  @objc var remoteLoadStatus: RemoteLoadStatus { get }
+internal protocol ErrorRecoveryDelegate: AnyObject {
+  var config: UpdatesConfig { get }
+  var remoteLoadStatus: RemoteLoadStatus { get }
 
-  @objc func launchedUpdate() -> Update?
-  @objc func relaunch(completion: @escaping (_ error: Error?, _ success: Bool) -> Void)
-  @objc func loadRemoteUpdate()
+  func launchedUpdate() -> Update?
+  func relaunch(completion: @escaping (_ error: Error?, _ success: Bool) -> Void)
+  func loadRemoteUpdate()
 
-  @objc func markFailedLaunchForLaunchedUpdate()
-  @objc func markSuccessfulLaunchForLaunchedUpdate()
+  func markFailedLaunchForLaunchedUpdate()
+  func markSuccessfulLaunchForLaunchedUpdate()
 
-  @objc func throwException(_ exception: NSException)
+  func throwException(_ exception: NSException)
 }
 
 /**
@@ -83,7 +82,7 @@ public final class ErrorRecovery: NSObject {
   private static let ErrorLogFile = "expo-error.log"
   private static let RemoteLoadTimeoutMs = 5000
 
-  public weak var delegate: ErrorRecoveryDelegate?
+  internal weak var delegate: (any ErrorRecoveryDelegate)?
 
   private var pipeline: [ErrorRecoveryTask]
   private var isRunning: Bool
@@ -92,7 +91,6 @@ public final class ErrorRecovery: NSObject {
   private let remoteLoadTimeout: Int
 
   private let errorRecoveryQueue: DispatchQueue
-  private let diskWriteQueue: DispatchQueue?
 
   private var encounteredErrors: [Any]
 
@@ -104,14 +102,12 @@ public final class ErrorRecovery: NSObject {
   public convenience override init() {
     self.init(
       errorRecoveryQueue: DispatchQueue(label: "expo.controller.errorRecoveryQueue"),
-      diskWriteQueue: nil,
       remoteLoadTimeout: ErrorRecovery.RemoteLoadTimeoutMs
     )
   }
 
   public required init(
     errorRecoveryQueue: DispatchQueue,
-    diskWriteQueue: DispatchQueue?,
     remoteLoadTimeout: Int
   ) {
     // tasks should never be added to the pipeline after this point, only removed
@@ -125,7 +121,6 @@ public final class ErrorRecovery: NSObject {
     self.isWaitingForRemoteUpdate = false
     self.rctContentHasAppeared = false
     self.errorRecoveryQueue = errorRecoveryQueue
-    self.diskWriteQueue = diskWriteQueue
     self.remoteLoadTimeout = remoteLoadTimeout
     self.encounteredErrors = []
     self.logger = UpdatesLogger()
@@ -137,12 +132,12 @@ public final class ErrorRecovery: NSObject {
 
   public func handle(error: NSError) {
     startPipeline(withEncounteredError: error)
-    writeErrorOrExceptionToLog(error)
+    ErrorRecovery.writeErrorOrExceptionToLog(error)
   }
 
   public func handle(exception: NSException) {
     startPipeline(withEncounteredError: exception)
-    writeErrorOrExceptionToLog(exception)
+    ErrorRecovery.writeErrorOrExceptionToLog(exception)
   }
 
   public func notify(newRemoteLoadStatus newStatus: RemoteLoadStatus) {
@@ -376,9 +371,8 @@ public final class ErrorRecovery: NSObject {
     return String(data: data, encoding: .utf8)
   }
 
-  public func writeErrorOrExceptionToLog(_ errorOrException: Any) {
-    let queue = diskWriteQueue ?? DispatchQueue.global()
-    queue.async {
+  public static func writeErrorOrExceptionToLog(_ errorOrException: Any, dispatchQueue: DispatchQueue = DispatchQueue.global()) {
+    dispatchQueue.async {
       var serializedError: String
       if let errorOrException = errorOrException as? NSError {
         serializedError = "Fatal error: \(ErrorRecovery.serialize(error: errorOrException))"
@@ -388,7 +382,7 @@ public final class ErrorRecovery: NSObject {
         return
       }
 
-      self.logger.error(message: "ErrorRecovery fatal exception: \(serializedError)", code: .jsRuntimeError)
+      UpdatesLogger().error(message: "ErrorRecovery fatal exception: \(serializedError)", code: .jsRuntimeError)
       let data = serializedError.data(using: .utf8)!
       let errorLogFile = ErrorRecovery.errorLogFile()
       if FileManager.default.fileExists(atPath: errorLogFile.path) {
diff --git a/node_modules/expo-updates/ios/EXUpdates/Exceptions.swift b/node_modules/expo-updates/ios/EXUpdates/Exceptions.swift
index aa9fa0e..9b9db62 100644
--- a/node_modules/expo-updates/ios/EXUpdates/Exceptions.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/Exceptions.swift
@@ -4,12 +4,12 @@
 
 import ExpoModulesCore
 
-internal final class UpdatesDisabledException: Exception {
-  override var code: String {
+public final class UpdatesDisabledException: Exception {
+  public override var code: String {
     "ERR_UPDATES_DISABLED"
   }
 
-  override var reason: String {
+  public override var reason: String {
     "Cannot call module method when expo-updates is disabled"
   }
 }
@@ -24,12 +24,12 @@ internal final class UpdatesNotInitializedException: Exception {
   }
 }
 
-internal final class UpdatesReloadException: Exception {
-  override var code: String {
+public final class UpdatesReloadException: Exception {
+  public override var code: String {
     "ERR_UPDATES_RELOAD"
   }
 
-  override var reason: String {
+  public override var reason: String {
     "Could not reload application. Ensure you have set the `bridge` property of AppController."
   }
 }
@@ -43,3 +43,13 @@ internal final class UpdatesUnsupportedDirectiveException: Exception {
     "Updates service response included a directive that this client does not support."
   }
 }
+
+internal final class NotAvailableInDevClientException: Exception {
+  override var code: String {
+    "ERR_NOT_AVAILABLE_IN_DEV_CLIENT"
+  }
+
+  override var reason: String {
+    "This method is not supported in dev client."
+  }
+}
diff --git a/node_modules/expo-updates/ios/EXUpdates/Logging/UpdatesLogReader.swift b/node_modules/expo-updates/ios/EXUpdates/Logging/UpdatesLogReader.swift
index f9d6ca1..0fbf807 100644
--- a/node_modules/expo-updates/ios/EXUpdates/Logging/UpdatesLogReader.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/Logging/UpdatesLogReader.swift
@@ -8,16 +8,18 @@ import ExpoModulesCore
 /**
  Class to read expo-updates logs using OSLogReader
  */
-internal final class UpdatesLogReader {
+public final class UpdatesLogReader {
   private let serialQueue = DispatchQueue(label: "dev.expo.updates.logging.reader")
   private let logPersistence = PersistentFileLog(category: UpdatesLogger.EXPO_UPDATES_LOG_CATEGORY)
 
+  public init() {}
+
   /**
    Get expo-updates logs newer than the given date
    Returns the log entries unpacked as dictionaries
    Maximum of one day lookback is allowed
    */
-  func getLogEntries(newerThan: Date) throws -> [[String: Any]] {
+  public func getLogEntries(newerThan: Date) throws -> [[String: Any]] {
     let epoch = epochFromDateOrOneDayAgo(date: newerThan)
     return logPersistence.readEntries()
       .compactMap { entryString in
@@ -30,7 +32,7 @@ internal final class UpdatesLogReader {
    Returned strings are all in the JSON format of UpdatesLogEntry
    Maximum of one day lookback is allowed
    */
-  func getLogEntries(newerThan: Date) -> [String] {
+  public func getLogEntries(newerThan: Date) -> [String] {
     let epoch = epochFromDateOrOneDayAgo(date: newerThan)
     return logPersistence.readEntries()
       .compactMap { entryString in
@@ -41,7 +43,7 @@ internal final class UpdatesLogReader {
   /**
    Purge all log entries written more than one day ago
    */
-  func purgeLogEntries(completion: @escaping (Error?) -> Void) {
+  public func purgeLogEntries(completion: @escaping (Error?) -> Void) {
     purgeLogEntries(
       olderThan: Date().addingTimeInterval(-UpdatesLogReader.MAXIMUM_LOOKBACK_INTERVAL),
       completion: completion
@@ -51,7 +53,7 @@ internal final class UpdatesLogReader {
   /**
    Purge all log entries written prior to the given date
    */
-  func purgeLogEntries(olderThan: Date, completion: @escaping (Error?) -> Void) {
+  public func purgeLogEntries(olderThan: Date, completion: @escaping (Error?) -> Void) {
     let epoch = epochFromDateOrOneDayAgo(date: olderThan)
     logPersistence.purgeEntriesNotMatchingFilter(filter: { entryString in
       self.logStringToFilteredLogEntry(entryString: entryString, epoch: epoch) != nil
diff --git a/node_modules/expo-updates/ios/EXUpdates/ReactDelegateHandler/ExpoUpdatesAppDelegateSubscriber.swift b/node_modules/expo-updates/ios/EXUpdates/ReactDelegateHandler/ExpoUpdatesAppDelegateSubscriber.swift
index 63bc3ef..c9e4612 100644
--- a/node_modules/expo-updates/ios/EXUpdates/ReactDelegateHandler/ExpoUpdatesAppDelegateSubscriber.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/ReactDelegateHandler/ExpoUpdatesAppDelegateSubscriber.swift
@@ -11,7 +11,7 @@ import EXUpdatesInterface
 public final class ExpoUpdatesAppDelegateSubscriber: ExpoAppDelegateSubscriber {
   public func application(_ application: UIApplication, willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
     if EXAppDefines.APP_DEBUG && !UpdatesUtils.isNativeDebuggingEnabled() {
-      UpdatesControllerRegistry.sharedInstance.controller = DevLauncherController.sharedInstance
+      UpdatesControllerRegistry.sharedInstance.controller = AppController.initializeAsDevLauncherWithoutStarting()
     }
     return true
   }
diff --git a/node_modules/expo-updates/ios/EXUpdates/ReactDelegateHandler/ExpoUpdatesReactDelegateHandler.swift b/node_modules/expo-updates/ios/EXUpdates/ReactDelegateHandler/ExpoUpdatesReactDelegateHandler.swift
index a2df0db..0a97abb 100644
--- a/node_modules/expo-updates/ios/EXUpdates/ReactDelegateHandler/ExpoUpdatesReactDelegateHandler.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/ReactDelegateHandler/ExpoUpdatesReactDelegateHandler.swift
@@ -36,7 +36,7 @@ public final class ExpoUpdatesReactDelegateHandler: ExpoReactDelegateHandler, Ap
 
     // Backward compatible if main AppDelegate already has expo-updates setup,
     // we just skip in this case.
-    if AppController.sharedInstance.isStarted {
+    if AppController.isInitialized() {
       return false
     }
 
@@ -49,6 +49,7 @@ public final class ExpoUpdatesReactDelegateHandler: ExpoReactDelegateHandler, Ap
     }
 
     self.reactDelegate = reactDelegate
+    AppController.initializeWithoutStarting(configuration: nil)
     let controller = AppController.sharedInstance
     controller.delegate = self
 
@@ -76,7 +77,7 @@ public final class ExpoUpdatesReactDelegateHandler: ExpoReactDelegateHandler, Ap
 
   // MARK: AppControllerDelegate implementations
 
-  public func appController(_ appController: AppController, didStartWithSuccess success: Bool) {
+  public func appController(_ appController: AppControllerInterface, didStartWithSuccess success: Bool) {
     guard let reactDelegate = self.reactDelegate else {
       fatalError("`reactDelegate` should not be nil")
     }
diff --git a/node_modules/expo-updates/ios/EXUpdates/Update/BareUpdate.swift b/node_modules/expo-updates/ios/EXUpdates/Update/BareUpdate.swift
index daca5e7..145fe8f 100644
--- a/node_modules/expo-updates/ios/EXUpdates/Update/BareUpdate.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/Update/BareUpdate.swift
@@ -15,7 +15,7 @@ public final class BareUpdate: Update {
     withBareManifest: BareManifest,
     config: UpdatesConfig,
     database: UpdatesDatabase?
-  ) -> Update {
+  ) -> BareUpdate {
     let manifest = withBareManifest
 
     let updateId = manifest.rawId()
@@ -46,14 +46,14 @@ public final class BareUpdate: Update {
       processedAssets.append(asset)
     }
 
-    let update = Update.init(
+    let update = BareUpdate.init(
       manifest: manifest,
       config: config,
       database: database,
       updateId: uuid,
       scopeKey: config.scopeKey,
       commitTime: Date(timeIntervalSince1970: Double(commitTime) / 1000),
-      runtimeVersion: UpdatesUtils.getRuntimeVersion(withConfig: config),
+      runtimeVersion: config.runtimeVersionRealized,
       keep: true,
       status: UpdateStatus.StatusEmbedded,
       isDevelopmentMode: false,
diff --git a/node_modules/expo-updates/ios/EXUpdates/Update/LegacyUpdate.swift b/node_modules/expo-updates/ios/EXUpdates/Update/LegacyUpdate.swift
index d0406da..9c7991c 100644
--- a/node_modules/expo-updates/ios/EXUpdates/Update/LegacyUpdate.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/Update/LegacyUpdate.swift
@@ -104,7 +104,7 @@ public final class LegacyUpdate: Update {
       config: config,
       database: database,
       updateId: updateId,
-      scopeKey: config.scopeKey.require("Must supply scopeKey in configuration"),
+      scopeKey: config.scopeKey,
       commitTime: commitTime,
       runtimeVersion: runtimeVersion,
       keep: true,
@@ -121,7 +121,7 @@ public final class LegacyUpdate: Update {
 
   static func bundledAssetBaseUrl(withManifest: LegacyManifest, config: UpdatesConfig) -> URL {
     let manifestUrl = config.updateUrl
-    let host = manifestUrl?.host
+    let host = manifestUrl.host
 
     guard let host = host else {
       // The URL is valid and constant, so it'll never throw
diff --git a/node_modules/expo-updates/ios/EXUpdates/Update/NewUpdate.swift b/node_modules/expo-updates/ios/EXUpdates/Update/NewUpdate.swift
index 7b1f271..189a5f5 100644
--- a/node_modules/expo-updates/ios/EXUpdates/Update/NewUpdate.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/Update/NewUpdate.swift
@@ -73,7 +73,7 @@ public final class NewUpdate: Update {
       config: config,
       database: database,
       updateId: uuid,
-      scopeKey: config.scopeKey.require("Must supply scopeKey in configuration"),
+      scopeKey: config.scopeKey,
       commitTime: RCTConvert.nsDate(commitTime),
       runtimeVersion: runtimeVersion,
       keep: true,
diff --git a/node_modules/expo-updates/ios/EXUpdates/Update/Update.swift b/node_modules/expo-updates/ios/EXUpdates/Update/Update.swift
index 36453b7..d43c2b6 100644
--- a/node_modules/expo-updates/ios/EXUpdates/Update/Update.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/Update/Update.swift
@@ -159,20 +159,12 @@ public class Update: NSObject {
     withEmbeddedManifest: [String: Any],
     config: UpdatesConfig,
     database: UpdatesDatabase?
-  ) -> Update {
-    if withEmbeddedManifest["releaseId"] != nil {
-      return LegacyUpdate.update(
-        withLegacyManifest: LegacyManifest(rawManifestJSON: withEmbeddedManifest),
-        config: config,
-        database: database
-      )
-    } else {
-      return BareUpdate.update(
-        withBareManifest: BareManifest(rawManifestJSON: withEmbeddedManifest),
-        config: config,
-        database: database
-      )
-    }
+  ) -> BareUpdate {
+    return BareUpdate.update(
+      withBareManifest: BareManifest(rawManifestJSON: withEmbeddedManifest),
+      config: config,
+      database: database
+    )
   }
 
   /**
diff --git a/node_modules/expo-updates/ios/EXUpdates/UpdatesConfig.swift b/node_modules/expo-updates/ios/EXUpdates/UpdatesConfig.swift
index ba2ac03..c4b213d 100644
--- a/node_modules/expo-updates/ios/EXUpdates/UpdatesConfig.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/UpdatesConfig.swift
@@ -11,7 +11,7 @@ public enum CheckAutomaticallyConfig: Int {
   case WifiOnly = 1
   case Never = 2
   case ErrorRecoveryOnly = 3
-  var asString: String {
+  public var asString: String {
     switch self {
     case .Always:
       return "ALWAYS"
@@ -28,6 +28,8 @@ public enum CheckAutomaticallyConfig: Int {
 @objc(EXUpdatesConfigError)
 public enum UpdatesConfigError: Int, Error {
   case ExpoUpdatesConfigPlistError
+  case ExpoUpdatesConfigMissingURLError
+  case ExpoUpdatesMissingRuntimeVersionError
 }
 
 /**
@@ -69,12 +71,11 @@ public final class UpdatesConfig: NSObject {
   public static let EXUpdatesConfigCheckOnLaunchValueErrorRecoveryOnly = "ERROR_RECOVERY_ONLY"
   public static let EXUpdatesConfigCheckOnLaunchValueNever = "NEVER"
 
-  private static let ReleaseChannelDefaultValue = "default"
+  public static let ReleaseChannelDefaultValue = "default"
 
-  public let isEnabled: Bool
   public let expectsSignedManifest: Bool
-  public let scopeKey: String?
-  public let updateUrl: URL?
+  public let scopeKey: String
+  public let updateUrl: URL
   public let requestHeaders: [String: String]
   public let releaseChannel: String
   public let launchWaitMs: Int
@@ -85,26 +86,26 @@ public final class UpdatesConfig: NSObject {
   public let enableExpoUpdatesProtocolV0CompatibilityMode: Bool
 
   public let sdkVersion: String?
-  public let runtimeVersion: String?
+  public let runtimeVersionRaw: String?
+  public let runtimeVersionRealized: String
 
   public let hasEmbeddedUpdate: Bool
 
   internal required init(
-    isEnabled: Bool,
     expectsSignedManifest: Bool,
-    scopeKey: String?,
-    updateUrl: URL?,
+    scopeKey: String,
+    updateUrl: URL,
     requestHeaders: [String: String],
     releaseChannel: String,
     launchWaitMs: Int,
     checkOnLaunch: CheckAutomaticallyConfig,
     codeSigningConfiguration: CodeSigningConfiguration?,
     sdkVersion: String?,
-    runtimeVersion: String?,
+    runtimeVersionRaw: String?,
+    runtimeVersionRealized: String,
     hasEmbeddedUpdate: Bool,
     enableExpoUpdatesProtocolV0CompatibilityMode: Bool
   ) {
-    self.isEnabled = isEnabled
     self.expectsSignedManifest = expectsSignedManifest
     self.scopeKey = scopeKey
     self.updateUrl = updateUrl
@@ -114,23 +115,17 @@ public final class UpdatesConfig: NSObject {
     self.checkOnLaunch = checkOnLaunch
     self.codeSigningConfiguration = codeSigningConfiguration
     self.sdkVersion = sdkVersion
-    self.runtimeVersion = runtimeVersion
+    self.runtimeVersionRaw = runtimeVersionRaw
+    self.runtimeVersionRealized = runtimeVersionRealized
     self.hasEmbeddedUpdate = hasEmbeddedUpdate
     self.enableExpoUpdatesProtocolV0CompatibilityMode = enableExpoUpdatesProtocolV0CompatibilityMode
   }
 
-  public func isMissingRuntimeVersion() -> Bool {
-    return (runtimeVersion?.isEmpty ?? true) && (sdkVersion?.isEmpty ?? true)
-  }
-
-  public static func configWithExpoPlist(mergingOtherDictionary: [String: Any]?) throws -> UpdatesConfig {
-    guard let configPath = Bundle.main.path(forResource: PlistName, ofType: "plist") else {
+  private static func configDictionaryWithExpoPlist(mergingOtherDictionary: [String: Any]?) throws -> [String: Any] {
+    guard let configPlistPath = Bundle.main.path(forResource: PlistName, ofType: "plist") else {
       throw UpdatesConfigError.ExpoUpdatesConfigPlistError
     }
-    return try configWithExpoPlist(configPlistPath: configPath, mergingOtherDictionary: mergingOtherDictionary)
-  }
 
-  public static func configWithExpoPlist(configPlistPath: String, mergingOtherDictionary: [String: Any]?) throws -> UpdatesConfig {
     // swiftlint:disable:next legacy_objc_type
     guard let configNSDictionary = NSDictionary(contentsOfFile: configPlistPath) as? [String: Any] else {
       throw UpdatesConfigError.ExpoUpdatesConfigPlistError
@@ -141,22 +136,55 @@ public final class UpdatesConfig: NSObject {
       dictionary = dictionary.merging(mergingOtherDictionary, uniquingKeysWith: { _, new in new })
     }
 
-    return UpdatesConfig.config(fromDictionary: dictionary)
+    return dictionary
   }
 
-  public static func config(fromDictionary config: [String: Any]) -> UpdatesConfig {
-    let isEnabled = config.optionalValue(forKey: EXUpdatesConfigEnabledKey) ?? true
-    let expectsSignedManifest = config.optionalValue(forKey: EXUpdatesConfigExpectsSignedManifestKey) ?? false
-    let updateUrl: URL? = config.optionalValue(forKey: EXUpdatesConfigUpdateUrlKey).let { it in
+  public static func isMissingRuntimeVersion(mergingOtherDictionary: [String: Any]?) -> Bool {
+    guard let dictionary = try? configDictionaryWithExpoPlist(mergingOtherDictionary: mergingOtherDictionary) else {
+      return true
+    }
+
+    let sdkVersion: String? = dictionary.optionalValue(forKey: EXUpdatesConfigSDKVersionKey)
+    let runtimeVersion: String? = dictionary.optionalValue(forKey: EXUpdatesConfigRuntimeVersionKey)
+
+    return (sdkVersion?.isEmpty ?? true) && (runtimeVersion?.isEmpty ?? true)
+  }
+
+  public static func canCreateValidConfiguration(mergingOtherDictionary: [String: Any]?) -> Bool {
+    guard let dictionary = try? configDictionaryWithExpoPlist(mergingOtherDictionary: mergingOtherDictionary) else {
+      return false
+    }
+
+    guard dictionary.optionalValue(forKey: EXUpdatesConfigEnabledKey) ?? true else {
+      return false
+    }
+
+    let updateUrl: URL? = dictionary.optionalValue(forKey: EXUpdatesConfigUpdateUrlKey).let { it in
       URL(string: it)
     }
+    guard updateUrl != nil else {
+      return false
+    }
 
-    var scopeKey: String? = config.optionalValue(forKey: EXUpdatesConfigScopeKeyKey)
-    if scopeKey == nil,
-      let updateUrl = updateUrl {
-      scopeKey = UpdatesConfig.normalizedURLOrigin(url: updateUrl)
+    if isMissingRuntimeVersion(mergingOtherDictionary: mergingOtherDictionary) {
+      return false
     }
 
+    return true
+  }
+
+  public static func configWithExpoPlist(mergingOtherDictionary: [String: Any]?) throws -> UpdatesConfig {
+    let dictionary = try configDictionaryWithExpoPlist(mergingOtherDictionary: mergingOtherDictionary)
+    return try UpdatesConfig.config(fromDictionary: dictionary)
+  }
+
+  public static func config(fromDictionary config: [String: Any]) throws -> UpdatesConfig {
+    let expectsSignedManifest = config.optionalValue(forKey: EXUpdatesConfigExpectsSignedManifestKey) ?? false
+    guard let updateUrl = URL(string: config.requiredValue(forKey: EXUpdatesConfigUpdateUrlKey)) else {
+      throw UpdatesConfigError.ExpoUpdatesConfigMissingURLError
+    }
+    let scopeKey = config.optionalValue(forKey: EXUpdatesConfigScopeKeyKey) ?? UpdatesConfig.normalizedURLOrigin(url: updateUrl)
+
     let requestHeaders: [String: String] = config.optionalValue(forKey: EXUpdatesConfigRequestHeadersKey) ?? [:]
     let releaseChannel = config.optionalValue(forKey: EXUpdatesConfigReleaseChannelKey) ?? ReleaseChannelDefaultValue
     let launchWaitMs = config.optionalValue(forKey: EXUpdatesConfigLaunchWaitMsKey).let { (it: Any) in
@@ -189,7 +217,12 @@ public final class UpdatesConfig: NSObject {
     } ?? CheckAutomaticallyConfig.Always
 
     let sdkVersion: String? = config.optionalValue(forKey: EXUpdatesConfigSDKVersionKey)
-    let runtimeVersion: String? = config.optionalValue(forKey: EXUpdatesConfigRuntimeVersionKey)
+    let runtimeVersionRaw: String? = config.optionalValue(forKey: EXUpdatesConfigRuntimeVersionKey)
+
+    guard let runtimeVersionRealized = runtimeVersionRaw ?? sdkVersion else {
+      throw UpdatesConfigError.ExpoUpdatesMissingRuntimeVersionError
+    }
+
     let hasEmbeddedUpdate = config.optionalValue(forKey: EXUpdatesConfigHasEmbeddedUpdateKey) ?? true
 
     let codeSigningConfiguration = config.optionalValue(forKey: EXUpdatesConfigCodeSigningCertificateKey).let { (certificateString: String) in
@@ -210,7 +243,6 @@ public final class UpdatesConfig: NSObject {
     let enableExpoUpdatesProtocolV0CompatibilityMode = config.optionalValue(forKey: EXUpdatesConfigEnableExpoUpdatesProtocolV0CompatibilityModeKey) ?? false
 
     return UpdatesConfig(
-      isEnabled: isEnabled,
       expectsSignedManifest: expectsSignedManifest,
       scopeKey: scopeKey,
       updateUrl: updateUrl,
@@ -220,7 +252,8 @@ public final class UpdatesConfig: NSObject {
       checkOnLaunch: checkOnLaunch,
       codeSigningConfiguration: codeSigningConfiguration,
       sdkVersion: sdkVersion,
-      runtimeVersion: runtimeVersion,
+      runtimeVersionRaw: runtimeVersionRaw,
+      runtimeVersionRealized: runtimeVersionRealized,
       hasEmbeddedUpdate: hasEmbeddedUpdate,
       enableExpoUpdatesProtocolV0CompatibilityMode: enableExpoUpdatesProtocolV0CompatibilityMode
     )
diff --git a/node_modules/expo-updates/ios/EXUpdates/UpdatesModule.swift b/node_modules/expo-updates/ios/EXUpdates/UpdatesModule.swift
index de6c136..6139fc9 100644
--- a/node_modules/expo-updates/ios/EXUpdates/UpdatesModule.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/UpdatesModule.swift
@@ -15,28 +15,21 @@ import ExpoModulesCore
  * by EXUpdatesBinding, a scoped module, in Expo Go.
  */
 public final class UpdatesModule: Module {
-  private let updatesService: EXUpdatesModuleInterface?
-  private let methodQueue = UpdatesUtils.methodQueue
-
-  public required init(appContext: AppContext) {
-    updatesService = appContext.legacyModule(implementing: EXUpdatesModuleInterface.self)
-    super.init(appContext: appContext)
-  }
-
   // swiftlint:disable cyclomatic_complexity
   public func definition() -> ModuleDefinition {
     Name("ExpoUpdates")
 
     Constants {
-      let releaseChannel = updatesService?.config?.releaseChannel
-      let channel = updatesService?.config?.requestHeaders["expo-channel-name"] ?? ""
-      let runtimeVersion = updatesService?.config?.runtimeVersion ?? ""
-      let checkAutomatically = updatesService?.config?.checkOnLaunch.asString ?? CheckAutomaticallyConfig.Always.asString
-      let isMissingRuntimeVersion = updatesService?.config?.isMissingRuntimeVersion()
-
-      guard let updatesService = updatesService,
-        updatesService.isStarted,
-        let launchedUpdate = updatesService.launchedUpdate else {
+      let constantsForModule = AppController.sharedInstance.getConstantsForModule()
+
+      let releaseChannel = constantsForModule.releaseChannel
+      let channel = constantsForModule.requestHeaders["expo-channel-name"] ?? ""
+      let runtimeVersion = constantsForModule.runtimeVersion ?? ""
+      let checkAutomatically = constantsForModule.checkOnLaunch.asString
+      let isMissingRuntimeVersion = constantsForModule.isMissingRuntimeVersion
+
+      guard AppController.sharedInstance.isStarted,
+        let launchedUpdate = constantsForModule.launchedUpdate else {
         return [
           "isEnabled": false,
           "isEmbeddedLaunch": false,
@@ -48,15 +41,18 @@ public final class UpdatesModule: Module {
         ]
       }
 
+      let embeddedUpdate = constantsForModule.embeddedUpdate
+      let isEmbeddedLaunch = embeddedUpdate != nil && embeddedUpdate?.updateId == launchedUpdate.updateId
+
       let commitTime = UInt64(floor(launchedUpdate.commitTime.timeIntervalSince1970 * 1000))
       return [
         "isEnabled": true,
-        "isEmbeddedLaunch": updatesService.isEmbeddedLaunch,
-        "isUsingEmbeddedAssets": updatesService.isUsingEmbeddedAssets,
+        "isEmbeddedLaunch": isEmbeddedLaunch,
+        "isUsingEmbeddedAssets": constantsForModule.isUsingEmbeddedAssets,
         "updateId": launchedUpdate.updateId.uuidString,
         "manifest": launchedUpdate.manifest.rawManifestJSON(),
-        "localAssets": updatesService.assetFilesMap ?? [:],
-        "isEmergencyLaunch": updatesService.isEmergencyLaunch,
+        "localAssets": constantsForModule.assetFilesMap,
+        "isEmergencyLaunch": constantsForModule.isEmergencyLaunch,
         "isMissingRuntimeVersion": isMissingRuntimeVersion,
         "releaseChannel": releaseChannel,
         "runtimeVersion": runtimeVersion,
@@ -68,104 +64,58 @@ public final class UpdatesModule: Module {
     }
 
     AsyncFunction("reload") { (promise: Promise) in
-      guard let updatesService = updatesService, let config = updatesService.config, config.isEnabled else {
-        throw UpdatesDisabledException()
-      }
-      guard updatesService.canRelaunch else {
-        throw UpdatesNotInitializedException()
-      }
-      updatesService.requestRelaunch { success in
-        if success {
-          promise.resolve(nil)
-        } else {
-          promise.reject(UpdatesReloadException())
-        }
+      AppController.sharedInstance.requestRelaunch {
+        promise.resolve(nil)
+      } error: { error in
+        promise.reject(error)
       }
     }
 
     AsyncFunction("checkForUpdateAsync") { (promise: Promise) in
-      let maybeIsCheckForUpdateEnabled: Bool? = updatesService?.canCheckForUpdateAndFetchUpdate ?? true
-      guard maybeIsCheckForUpdateEnabled ?? false else {
-        promise.reject("ERR_UPDATES_CHECK", "checkForUpdateAsync() is not enabled")
-        return
-      }
-      UpdatesUtils.checkForUpdate { result in
-        if result["message"] != nil {
-          guard let message = result["message"] as? String else {
-            promise.reject("ERR_UPDATES_CHECK", "")
-            return
-          }
-          promise.reject("ERR_UPDATES_CHECK", message)
+      AppController.sharedInstance.checkForUpdate { remoteCheckResult in
+        switch remoteCheckResult {
+        case .noUpdateAvailable(let reason):
+          promise.resolve([
+            "isAvailable": false,
+            "isRollBackToEmbedded": false,
+            "reason": reason
+          ])
           return
-        }
-        if result["manifest"] != nil {
+        case .updateAvailable(let manifest):
           promise.resolve([
             "isAvailable": true,
-            "manifest": result["manifest"],
+            "manifest": manifest,
             "isRollBackToEmbedded": false
           ])
           return
-        }
-        if result["isRollBackToEmbedded"] != nil {
+        case .rollBackToEmbedded:
           promise.resolve([
             "isAvailable": false,
-            "isRollBackToEmbedded": result["isRollBackToEmbedded"]
+            "isRollBackToEmbedded": true
           ])
           return
-        }
-        if result["reason"] != nil {
-          promise.resolve([
-            "isAvailable": false,
-            "isRollBackToEmbedded": false,
-            "reason": result["reason"]
-          ])
+        case .error(let error):
+          promise.reject("ERR_UPDATES_CHECK", error.localizedDescription)
           return
         }
-        promise.resolve([
-          "isAvailable": false,
-          "isRollBackToEmbedded": false
-        ])
+      } error: { error in
+        promise.reject(error)
       }
     }
 
     AsyncFunction("getExtraParamsAsync") { (promise: Promise) in
-      guard let updatesService = updatesService,
-        let config = updatesService.config,
-        config.isEnabled else {
-        throw UpdatesDisabledException()
-      }
-
-      guard let scopeKey = config.scopeKey else {
-        throw Exception(name: "ERR_UPDATES_SCOPE_KEY", description: "Muse have scopeKey in config")
-      }
-
-      updatesService.database.databaseQueue.async {
-        do {
-          promise.resolve(try updatesService.database.extraParams(withScopeKey: scopeKey))
-        } catch {
-          promise.reject(error)
-        }
+      AppController.sharedInstance.getExtraParams { extraParams in
+        promise.resolve(extraParams)
+      } error: { error in
+        promise.reject(error)
       }
     }
 
     AsyncFunction("setExtraParamAsync") { (key: String, value: String?, promise: Promise) in
-      guard let updatesService = updatesService,
-        let config = updatesService.config,
-        config.isEnabled else {
-        throw UpdatesDisabledException()
-      }
-
-      guard let scopeKey = config.scopeKey else {
-        throw Exception(name: "ERR_UPDATES_SCOPE_KEY", description: "Muse have scopeKey in config")
-      }
-
-      updatesService.database.databaseQueue.async {
-        do {
-          try updatesService.database.setExtraParam(key: key, value: value, withScopeKey: scopeKey)
-          promise.resolve(nil)
-        } catch {
-          promise.reject(error)
-        }
+      AppController.sharedInstance.setExtraParam(key: key, value: value) {
+        promise.resolve(nil)
+      } error: { error in
+        promise.reject(error)
       }
     }
 
@@ -189,44 +139,43 @@ public final class UpdatesModule: Module {
     }
 
     AsyncFunction("fetchUpdateAsync") { (promise: Promise) in
-      let maybeIsCheckForUpdateEnabled: Bool? = updatesService?.canCheckForUpdateAndFetchUpdate ?? true
-      guard maybeIsCheckForUpdateEnabled ?? false else {
-        promise.reject("ERR_UPDATES_FETCH", "fetchUpdateAsync() is not enabled")
-        return
-      }
-      UpdatesUtils.fetchUpdate { result in
-        if result["message"] != nil {
-          guard let message = result["message"] as? String else {
-            promise.reject("ERR_UPDATES_FETCH", "")
-            return
-          }
-          promise.reject("ERR_UPDATES_FETCH", message)
+      AppController.sharedInstance.fetchUpdate { fetchUpdateResult in
+        switch fetchUpdateResult {
+        case .success(let manifest):
+          promise.resolve([
+            "isNew": true,
+            "isRollBackToEmbedded": false,
+            "manifest": manifest
+          ])
+          return
+        case .failure:
+          promise.resolve([
+            "isNew": false,
+            "isRollBackToEmbedded": false
+          ])
+          return
+        case .rollBackToEmbedded:
+          promise.resolve([
+            "isNew": false,
+            "isRollBackToEmbedded": true
+          ])
+          return
+        case .error(let error):
+          promise.reject("ERR_UPDATES_FETCH", error.localizedDescription)
           return
-        } else {
-          promise.resolve(result)
         }
+      } error: { error in
+        promise.reject(error)
       }
     }
 
     // Getter used internally by useUpdates()
     // to initialize its state
     AsyncFunction("getNativeStateMachineContextAsync") { (promise: Promise) in
-      let maybeIsCheckForUpdateEnabled: Bool? = updatesService?.canCheckForUpdateAndFetchUpdate ?? true
-      guard maybeIsCheckForUpdateEnabled ?? false else {
-        promise.resolve(UpdatesUtils.defaultNativeStateMachineContextJson())
-        return
-      }
-      UpdatesUtils.getNativeStateMachineContextJson { result in
-        if result["message"] != nil {
-          guard let message = result["message"] as? String else {
-            promise.reject("ERR_UPDATES_CHECK", "")
-            return
-          }
-          promise.reject("ERR_UPDATES_CHECK", message)
-          return
-        } else {
-          promise.resolve(result)
-        }
+      AppController.sharedInstance.getNativeStateMachineContext { stateMachineContext in
+        promise.resolve(stateMachineContext.json)
+      } error: { error in
+        promise.reject(error)
       }
     }
   }
diff --git a/node_modules/expo-updates/ios/EXUpdates/UpdatesModule.swift.orig b/node_modules/expo-updates/ios/EXUpdates/UpdatesModule.swift.orig
new file mode 100644
index 0000000..132279b
--- /dev/null
+++ b/node_modules/expo-updates/ios/EXUpdates/UpdatesModule.swift.orig
@@ -0,0 +1,228 @@
+// Copyright 2019 650 Industries. All rights reserved.
+
+// swiftlint:disable closure_body_length
+// swiftlint:disable superfluous_else
+
+import ExpoModulesCore
+
+/**
+ * Exported module which provides to the JS runtime information about the currently running update
+ * and updates state, along with methods to check for and download new updates, reload with the
+ * newest downloaded update applied, and read/clear native log entries.
+ *
+ * Communicates with the updates hub (AppController in most apps, EXAppLoaderExpoUpdates in
+ * Expo Go and legacy standalone apps) via EXUpdatesService, an internal module which is overridden
+ * by EXUpdatesBinding, a scoped module, in Expo Go.
+ */
+public final class UpdatesModule: Module {
+  // swiftlint:disable cyclomatic_complexity
+  public func definition() -> ModuleDefinition {
+    Name("ExpoUpdates")
+
+    Constants {
+      let config = AppController.sharedInstance.config
+      let releaseChannel = config.releaseChannel
+      let channel = config.requestHeaders["expo-channel-name"] ?? ""
+      let runtimeVersion = config.runtimeVersion ?? ""
+      let checkAutomatically = config.checkOnLaunch.asString
+      let isMissingRuntimeVersion = config.isMissingRuntimeVersion()
+
+      guard AppController.sharedInstance.isStarted,
+        let launchedUpdate = AppController.sharedInstance.launchedUpdate() else {
+        return [
+          "isEnabled": false,
+          "isEmbeddedLaunch": false,
+          "isMissingRuntimeVersion": isMissingRuntimeVersion,
+          "releaseChannel": releaseChannel,
+          "runtimeVersion": runtimeVersion,
+          "checkAutomatically": checkAutomatically,
+          "channel": channel
+        ]
+      }
+
+      let embeddedUpdate = AppController.sharedInstance.getEmbeddedUpdate()
+      let isEmbeddedLaunch = embeddedUpdate != nil && embeddedUpdate?.updateId == launchedUpdate.updateId
+
+      let commitTime = UInt64(floor(launchedUpdate.commitTime.timeIntervalSince1970 * 1000))
+      return [
+        "isEnabled": true,
+        "isEmbeddedLaunch": isEmbeddedLaunch,
+        "isUsingEmbeddedAssets": AppController.sharedInstance.isUsingEmbeddedAssets,
+        "updateId": launchedUpdate.updateId.uuidString,
+        "manifest": launchedUpdate.manifest.rawManifestJSON(),
+        "localAssets": AppController.sharedInstance.assetFilesMap,
+        "isEmergencyLaunch": AppController.sharedInstance.isEmergencyLaunch,
+        "isMissingRuntimeVersion": isMissingRuntimeVersion,
+        "releaseChannel": releaseChannel,
+        "runtimeVersion": runtimeVersion,
+        "checkAutomatically": checkAutomatically,
+        "channel": channel,
+        "commitTime": commitTime,
+        "nativeDebug": UpdatesUtils.isNativeDebuggingEnabled()
+      ]
+    }
+
+    AsyncFunction("reload") { (promise: Promise) in
+      let config = AppController.sharedInstance.config
+      guard config.isEnabled else {
+        throw UpdatesDisabledException()
+      }
+      guard AppController.sharedInstance.isStarted else {
+        throw UpdatesNotInitializedException()
+      }
+      AppController.sharedInstance.requestRelaunch { success in
+        if success {
+          promise.resolve(nil)
+        } else {
+          promise.reject(UpdatesReloadException())
+        }
+      }
+    }
+
+    AsyncFunction("checkForUpdateAsync") { (promise: Promise) in
+      let config = AppController.sharedInstance.config
+      guard config.isEnabled else {
+        throw UpdatesDisabledException()
+      }
+      guard AppController.sharedInstance.isStarted else {
+        throw UpdatesNotInitializedException()
+      }
+
+      AppController.sharedInstance.checkForUpdate { remoteCheckResult in
+        switch remoteCheckResult {
+        case .noUpdateAvailable(let reason):
+          promise.resolve([
+            "isAvailable": false,
+            "isRollBackToEmbedded": false,
+            "reason": reason
+          ])
+          return
+        case .updateAvailable(let manifest):
+          promise.resolve([
+            "isAvailable": true,
+            "manifest": manifest,
+            "isRollBackToEmbedded": false
+          ])
+          return
+        case .rollBackToEmbedded:
+          promise.resolve([
+            "isAvailable": false,
+            "isRollBackToEmbedded": true
+          ])
+          return
+        case .error(let error):
+          promise.reject("ERR_UPDATES_CHECK", error.localizedDescription)
+          return
+        }
+      }
+    }
+
+    AsyncFunction("getExtraParamsAsync") { (promise: Promise) in
+      let config = AppController.sharedInstance.config
+      guard config.isEnabled else {
+        throw UpdatesDisabledException()
+      }
+      guard AppController.sharedInstance.isStarted else {
+        throw UpdatesNotInitializedException()
+      }
+
+      AppController.sharedInstance.getExtraParams { extraParams in
+        promise.resolve(extraParams)
+      } error: { error in
+        promise.reject(error)
+      }
+    }
+
+    AsyncFunction("setExtraParamAsync") { (key: String, value: String?, promise: Promise) in
+      let config = AppController.sharedInstance.config
+      guard config.isEnabled else {
+        throw UpdatesDisabledException()
+      }
+      guard AppController.sharedInstance.isStarted else {
+        throw UpdatesNotInitializedException()
+      }
+
+      AppController.sharedInstance.setExtraParam(key: key, value: value) {
+        promise.resolve(nil)
+      } error: { error in
+        promise.reject(error)
+      }
+    }
+
+    AsyncFunction("readLogEntriesAsync") { (maxAge: Int) -> [[String: Any]] in
+      // maxAge is in milliseconds, convert to seconds
+      do {
+        return try UpdatesLogReader().getLogEntries(newerThan: Date(timeIntervalSinceNow: TimeInterval(-1 * (maxAge / 1000))))
+      } catch {
+        throw Exception(name: "ERR_UPDATES_READ_LOGS", description: error.localizedDescription)
+      }
+    }
+
+    AsyncFunction("clearLogEntriesAsync") { (promise: Promise) in
+      UpdatesLogReader().purgeLogEntries(olderThan: Date()) { error in
+        guard let error = error else {
+          promise.resolve(nil)
+          return
+        }
+        promise.reject("ERR_UPDATES_READ_LOGS", error.localizedDescription)
+      }
+    }
+
+    AsyncFunction("fetchUpdateAsync") { (promise: Promise) in
+      let config = AppController.sharedInstance.config
+      guard config.isEnabled else {
+        throw UpdatesDisabledException()
+      }
+      guard AppController.sharedInstance.isStarted else {
+        throw UpdatesNotInitializedException()
+      }
+
+      AppController.sharedInstance.fetchUpdate { fetchUpdateResult in
+        switch fetchUpdateResult {
+        case .success(let manifest):
+          promise.resolve([
+            "isNew": true,
+            "isRollBackToEmbedded": false,
+            "manifest": manifest
+          ])
+          return
+        case .failure:
+          promise.resolve([
+            "isNew": false,
+            "isRollBackToEmbedded": false
+          ])
+          return
+        case .rollBackToEmbedded:
+          promise.resolve([
+            "isNew": false,
+            "isRollBackToEmbedded": true
+          ])
+          return
+        case .error(let error):
+          promise.reject("ERR_UPDATES_FETCH", error.localizedDescription)
+          return
+        }
+      }
+    }
+
+    // Getter used internally by useUpdates()
+    // to initialize its state
+    AsyncFunction("getNativeStateMachineContextAsync") { (promise: Promise) in
+      let config = AppController.sharedInstance.config
+      guard config.isEnabled else {
+        throw UpdatesDisabledException()
+      }
+      guard AppController.sharedInstance.isStarted else {
+        throw UpdatesNotInitializedException()
+      }
+
+      AppController.sharedInstance.getNativeStateMachineContext { stateMachineContext in
+        promise.resolve(stateMachineContext.json)
+      }
+    }
+  }
+  // swiftlint:enable cyclomatic_complexity
+}
+
+// swiftlint:enable closure_body_length
+// swiftlint:enable superfluous_else
diff --git a/node_modules/expo-updates/ios/EXUpdates/UpdatesStateMachine.swift b/node_modules/expo-updates/ios/EXUpdates/UpdatesStateMachine.swift
index f80fbef..e9e7c8c 100644
--- a/node_modules/expo-updates/ios/EXUpdates/UpdatesStateMachine.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/UpdatesStateMachine.swift
@@ -169,7 +169,7 @@ internal struct UpdatesStateContextRollback {
 /**
  The state machine context, with information that will be readable from JS.
  */
-internal struct UpdatesStateContext {
+public struct UpdatesStateContext {
   let isUpdateAvailable: Bool
   let isUpdatePending: Bool
   let isRollback: Bool
@@ -289,16 +289,12 @@ extension UpdatesStateContext {
 internal class UpdatesStateMachine {
   private let logger = UpdatesLogger()
 
-  init(changeEventDelegate: (any UpdatesStateChangeDelegate)) {
-    self.changeEventDelegate = changeEventDelegate
-  }
-
   // MARK: - Public methods and properties
 
   /**
    In production, this is the AppController instance.
    */
-  private weak var changeEventDelegate: (any UpdatesStateChangeDelegate)?
+  internal weak var changeEventDelegate: (any UpdatesStateChangeDelegate)?
 
   /**
    The current state
diff --git a/node_modules/expo-updates/ios/EXUpdates/UpdatesUtils.swift b/node_modules/expo-updates/ios/EXUpdates/UpdatesUtils.swift
index 6d0d8ff..d98b34c 100644
--- a/node_modules/expo-updates/ios/EXUpdates/UpdatesUtils.swift
+++ b/node_modules/expo-updates/ios/EXUpdates/UpdatesUtils.swift
@@ -1,8 +1,6 @@
 //  Copyright © 2019 650 Industries. All rights reserved.
 
 // swiftlint:disable force_unwrapping
-// swiftlint:disable closure_body_length
-// swiftlint:disable superfluous_else
 
 import Foundation
 import SystemConfiguration
@@ -21,9 +19,7 @@ internal extension Array where Element: Equatable {
 @objc(EXUpdatesUtils)
 @objcMembers
 public final class UpdatesUtils: NSObject {
-  private static let EXUpdatesEventName = "Expo.nativeUpdatesEvent"
   private static let EXUpdatesUtilsErrorDomain = "EXUpdatesUtils"
-  public static let methodQueue = DispatchQueue(label: "expo.modules.EXUpdatesQueue")
 
   // MARK: - Public methods
 
@@ -63,262 +59,12 @@ public final class UpdatesUtils: NSObject {
     return updatesDirectory
   }
 
-  /**
-   The implementation of checkForUpdateAsync().
-   The UpdatesService is passed in when this is called from JS through UpdatesModule
-   */
-  public static func checkForUpdate(_ block: @escaping ([String: Any]) -> Void) {
-    sendStateEvent(UpdatesStateEventCheck())
-    do {
-      let constants = try startJSAPICall()
-
-      var extraHeaders: [String: Any] = [:]
-      constants.database.databaseQueue.sync {
-        extraHeaders = FileDownloader.extraHeadersForRemoteUpdateRequest(
-          withDatabase: constants.database,
-          config: constants.config,
-          launchedUpdate: constants.launchedUpdate,
-          embeddedUpdate: constants.embeddedUpdate
-        )
-      }
-
-      let fileDownloader = FileDownloader(config: constants.config)
-      fileDownloader.downloadRemoteUpdate(
-        fromURL: constants.config.updateUrl!,
-        withDatabase: constants.database,
-        extraHeaders: extraHeaders
-      ) { updateResponse in
-        let launchedUpdate = constants.launchedUpdate
-        let manifestFilters = updateResponse.responseHeaderData?.manifestFilters
-
-        if let updateDirective = updateResponse.directiveUpdateResponsePart?.updateDirective {
-          switch updateDirective {
-          case is NoUpdateAvailableUpdateDirective:
-            block([:])
-            sendStateEvent(UpdatesStateEventCheckComplete())
-            return
-          case let rollBackUpdateDirective as RollBackToEmbeddedUpdateDirective:
-            if !constants.config.hasEmbeddedUpdate {
-              let reason = RemoteCheckResultNotAvailableReason.rollbackNoEmbedded
-              block([
-                "reason": "\(reason)"
-              ])
-              sendStateEvent(UpdatesStateEventCheckComplete())
-              return
-            }
-
-            guard let embeddedManifest = EmbeddedAppLoader.embeddedManifest(withConfig: constants.config, database: constants.database) else {
-              let reason = RemoteCheckResultNotAvailableReason.rollbackNoEmbedded
-              block([
-                "reason": "\(reason)"
-              ])
-              sendStateEvent(UpdatesStateEventCheckComplete())
-              return
-            }
-
-            if !constants.selectionPolicy.shouldLoadRollBackToEmbeddedDirective(
-              rollBackUpdateDirective,
-              withEmbeddedUpdate: embeddedManifest,
-              launchedUpdate: launchedUpdate,
-              filters: manifestFilters
-            ) {
-              let reason = RemoteCheckResultNotAvailableReason.rollbackRejectedBySelectionPolicy
-              block([
-                "reason": "\(reason)"
-              ])
-              sendStateEvent(UpdatesStateEventCheckComplete())
-              return
-            }
-
-            block([
-              "isRollBackToEmbedded": true
-            ])
-            sendStateEvent(
-              UpdatesStateEventCheckCompleteWithRollback(
-                rollbackCommitTime: RollBackToEmbeddedUpdateDirective.rollbackCommitTime(rollBackUpdateDirective)
-              )
-            )
-            return
-          default:
-            return handleCheckError(UpdatesUnsupportedDirectiveException(), block: block)
-          }
-        }
-
-        guard let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
-          let reason = RemoteCheckResultNotAvailableReason.noUpdateAvailableOnServer
-          block([
-            "reason": "\(reason)"
-          ])
-          sendStateEvent(UpdatesStateEventCheckComplete())
-          return
-        }
-
-        var shouldLaunch = false
-        var failedPreviously = false
-        if constants.selectionPolicy.shouldLoadNewUpdate(
-          update,
-          withLaunchedUpdate: launchedUpdate,
-          filters: manifestFilters
-        ) {
-          // If "update" has failed to launch previously, then
-          // "launchedUpdate" will be an earlier update, and the test above
-          // will return true (incorrectly).
-          // We check to see if the new update is already in the DB, and if so,
-          // only allow the update if it has had no launch failures.
-          shouldLaunch = true
-          constants.database.databaseQueue.sync {
-            do {
-              let storedUpdate = try constants.database.update(withId: update.updateId, config: constants.config)
-              if let storedUpdate = storedUpdate {
-                shouldLaunch = storedUpdate.failedLaunchCount == 0 || storedUpdate.successfulLaunchCount > 0
-                failedPreviously = !shouldLaunch
-                AppController.sharedInstance.logger.info(message: "Stored update found: ID = \(update.updateId), failureCount = \(storedUpdate.failedLaunchCount)")
-              }
-            } catch {}
-          }
-        }
-        if shouldLaunch {
-          block([
-            "manifest": update.manifest.rawManifestJSON()
-          ])
-          sendStateEvent(UpdatesStateEventCheckCompleteWithUpdate(manifest: update.manifest.rawManifestJSON()))
-        } else {
-          let reason = failedPreviously ?
-            RemoteCheckResultNotAvailableReason.updatePreviouslyFailed :
-            RemoteCheckResultNotAvailableReason.updateRejectedBySelectionPolicy
-          block([
-            "reason": "\(reason)"
-          ])
-          sendStateEvent(UpdatesStateEventCheckComplete())
-        }
-      } errorBlock: { error in
-        return handleCheckError(error, block: block)
-      }
-    } catch {
-      return handleCheckError(error, block: block)
-    }
-  }
-
-  /**
-   The implementation of fetchUpdateAsync().
-   The UpdatesService is passed in when this is called from JS through UpdatesModule
-   */
-  public static func fetchUpdate(_ block: @escaping ([String: Any]) -> Void) {
-    sendStateEvent(UpdatesStateEventDownload())
-    do {
-      let constants = try startJSAPICall()
-      let remoteAppLoader = RemoteAppLoader(
-        config: constants.config,
-        database: constants.database,
-        directory: constants.directory,
-        launchedUpdate: constants.launchedUpdate,
-        completionQueue: methodQueue
-      )
-      remoteAppLoader.loadUpdate(
-        fromURL: constants.config.updateUrl!
-      ) { updateResponse in
-        if let updateDirective = updateResponse.directiveUpdateResponsePart?.updateDirective {
-          switch updateDirective {
-          case is NoUpdateAvailableUpdateDirective:
-            return false
-          case is RollBackToEmbeddedUpdateDirective:
-            return true
-          default:
-            NSException(name: .internalInconsistencyException, reason: "Unhandled update directive type").raise()
-            return false
-          }
-        }
-
-        guard let update = updateResponse.manifestUpdateResponsePart?.updateManifest else {
-          return false
-        }
-
-        return constants.selectionPolicy.shouldLoadNewUpdate(
-          update,
-          withLaunchedUpdate: constants.launchedUpdate,
-          filters: updateResponse.responseHeaderData?.manifestFilters
-        )
-      } asset: { asset, successfulAssetCount, failedAssetCount, totalAssetCount in
-        let body = [
-          "assetInfo": [
-            "assetName": asset.filename,
-            "successfulAssetCount": successfulAssetCount,
-            "failedAssetCount": failedAssetCount,
-            "totalAssetCount": totalAssetCount
-          ] as [String: Any]
-        ] as [String: Any]
-        AppController.sharedInstance.logger.info(
-          message: "fetchUpdateAsync didLoadAsset: \(body)",
-          code: .none,
-          updateId: nil,
-          assetId: asset.contentHash
-        )
-      } success: { updateResponse in
-        RemoteAppLoader.processSuccessLoaderResult(
-          config: constants.config,
-          database: constants.database,
-          selectionPolicy: constants.selectionPolicy,
-          launchedUpdate: constants.launchedUpdate,
-          directory: constants.directory,
-          loaderTaskQueue: DispatchQueue(label: "expo.loader.LoaderTaskQueue"),
-          updateResponse: updateResponse,
-          priorError: nil
-        ) { updateToLaunch, error, didRollBackToEmbedded in
-          if let error = error {
-            return handleFetchError(error, block: block)
-          }
-
-          if didRollBackToEmbedded {
-            block([
-              "isNew": false,
-              "isRollBackToEmbedded": true
-            ])
-            sendStateEvent(UpdatesStateEventDownloadCompleteWithRollback())
-            return
-          } else {
-            if let update = updateToLaunch {
-              AppController.sharedInstance.resetSelectionPolicyToDefault()
-              block([
-                "isNew": true,
-                "isRollBackToEmbedded": false,
-                "manifest": update.manifest.rawManifestJSON()
-              ] as [String: Any])
-              sendStateEvent(UpdatesStateEventDownloadCompleteWithUpdate(manifest: update.manifest.rawManifestJSON()))
-              return
-            } else {
-              block([
-                "isNew": false,
-                "isRollBackToEmbedded": false
-              ])
-              sendStateEvent(UpdatesStateEventDownloadComplete())
-              return
-            }
-          }
-        }
-      } error: { error in
-        return handleFetchError(error, block: block)
-      }
-    } catch {
-      handleFetchError(error, block: block)
-    }
-  }
-
   // MARK: - Internal methods
 
-  internal static func defaultNativeStateMachineContextJson() -> [String: Any?] {
+  public static func defaultNativeStateMachineContextJson() -> [String: Any?] {
     return UpdatesStateContext().json
   }
 
-  internal static func getNativeStateMachineContextJson(_ block: @escaping ([String: Any?]) -> Void) {
-    do {
-      let constants = try startJSAPICall()
-      let result = constants.context?.json ?? defaultNativeStateMachineContextJson()
-      block(result)
-    } catch {
-      handleCheckError(error, block: block)
-    }
-  }
-
   internal static func shouldCheckForUpdate(withConfig config: UpdatesConfig) -> Bool {
     func isConnectedToWifi() -> Bool {
       do {
@@ -341,15 +87,23 @@ public final class UpdatesUtils: NSObject {
     }
   }
 
-  internal static func sendStateEvent(_ event: UpdatesStateEvent) {
-    AppController.sharedInstance.stateMachine?.processEvent(event)
-  }
+  internal static func embeddedAssetsMap(withConfig config: UpdatesConfig, database: UpdatesDatabase, logger: UpdatesLogger) -> [String: String] {
+    var assetFilesMap: [String: String] = [:]
+    let embeddedManifest: Update? = EmbeddedAppLoader.embeddedManifest(withConfig: config, database: database)
+    let embeddedAssets = embeddedManifest?.assets() ?? []
 
-  internal static func getRuntimeVersion(withConfig config: UpdatesConfig) -> String {
-    // various places in the code assume that we have a nonnull runtimeVersion, so if the developer
-    // hasn't configured either runtimeVersion or sdkVersion, we'll use a dummy value of "1" but warn
-    // the developer in JS that they need to configure one of these values
-    return config.runtimeVersion ?? config.sdkVersion ?? "1"
+    // Prepopulate with embedded assets
+    for asset in embeddedAssets {
+      if let assetKey = asset.key,
+        !asset.isLaunchAsset {
+        let absolutePath = path(forBundledAsset: asset)
+        let message = "AppLauncherWithDatabase: embedded asset key = \(asset.key ?? ""), main bundle filename = \(asset.mainBundleFilename ?? ""), path = \(absolutePath ?? "")"
+        logger.debug(message: message)
+        assetFilesMap[assetKey] = absolutePath
+      }
+    }
+
+    return assetFilesMap
   }
 
   internal static func url(forBundledAsset asset: UpdateAsset) -> URL? {
@@ -416,72 +170,6 @@ public final class UpdatesUtils: NSObject {
       .replacingOccurrences(of: "+", with: "-") // replace "+" character w/ "-"
       .replacingOccurrences(of: "/", with: "_") // replace "/" character w/ "_"
   }
-
-  // MARK: - Private methods used by API calls
-
-  /**
-   If any error occurs in checkForUpdate(), this will call the
-   completion block and fire the error notification
-   */
-  private static func handleCheckError(_ error: Error, block: @escaping ([String: Any]) -> Void) {
-    let body = ["message": error.localizedDescription]
-    sendStateEvent(UpdatesStateEventCheckError(message: error.localizedDescription))
-    block(body)
-  }
-
-  /**
-   If any error occurs in fetchUpdate(), this will call the
-   completion block and fire the error notification
-   */
-  private static func handleFetchError(_ error: Error, block: @escaping ([String: Any]) -> Void) {
-    let body = ["message": error.localizedDescription]
-    sendStateEvent(UpdatesStateEventDownloadError(message: error.localizedDescription))
-    block(body)
-  }
-
-  /**
-   Code that runs at the start of both checkForUpdate and fetchUpdate, to do sanity
-   checks and return the config, selection policy, database, etc.
-   When called from JS, the UpdatesService object will be passed in.
-   When called from elsewhere (e.g. in response to a notification),
-   a nil object is passed in, in which case we return the results directly
-   from the AppController.
-   Throws if expo-updates is not enabled or not started.
-   */
-  private static func startJSAPICall() throws -> (
-    config: UpdatesConfig,
-    selectionPolicy: SelectionPolicy,
-    database: UpdatesDatabase,
-    directory: URL,
-    launchedUpdate: Update?,
-    embeddedUpdate: Update?,
-    context: UpdatesStateContext?
-  ) {
-    let maybeConfig: UpdatesConfig? = AppController.sharedInstance.config
-    let maybeSelectionPolicy: SelectionPolicy? = AppController.sharedInstance.selectionPolicy()
-    let maybeIsStarted: Bool? = AppController.sharedInstance.isStarted
-
-    guard let config = maybeConfig,
-      let selectionPolicy = maybeSelectionPolicy,
-      config.isEnabled
-    else {
-      throw UpdatesDisabledException()
-    }
-    guard maybeIsStarted ?? false else {
-      throw UpdatesNotInitializedException()
-    }
-
-    let database = AppController.sharedInstance.database
-    let launchedUpdate = AppController.sharedInstance.launchedUpdate()
-    let embeddedUpdate = EmbeddedAppLoader.embeddedManifest(withConfig: config, database: database)
-    guard let directory = AppController.sharedInstance.updatesDirectory else {
-      throw UpdatesNotInitializedException()
-    }
-    let context = AppController.sharedInstance.stateMachine?.context
-    return (config, selectionPolicy, database, directory, launchedUpdate, embeddedUpdate, context)
-  }
 }
 
 // swiftlint:enable force_unwrapping
-// swiftlint:enable closure_body_length
-// swiftlint:enable superfluous_else
diff --git a/node_modules/expo-updates/ios/Tests/AppLauncherWithDatabaseSpec.swift b/node_modules/expo-updates/ios/Tests/AppLauncherWithDatabaseSpec.swift
index ea00dea..b2e0328 100644
--- a/node_modules/expo-updates/ios/Tests/AppLauncherWithDatabaseSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/AppLauncherWithDatabaseSpec.swift
@@ -10,7 +10,10 @@ class AppLauncherWithDatabaseMock : AppLauncherWithDatabase {
   public static let testUpdate: Update = {
     return Update(
       manifest: ManifestFactory.manifest(forManifestJSON: [:]),
-      config: UpdatesConfig.config(fromDictionary: [:]),
+      config: try! UpdatesConfig.config(fromDictionary: [
+        UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+        UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+      ]),
       database: UpdatesDatabase(),
       updateId: UUID(),
       scopeKey: "dummyScope",
@@ -63,37 +66,6 @@ class AppLauncherWithDatabaseSpec : ExpoSpec {
       try! FileManager.default.removeItem(atPath: testDatabaseDir.path)
     }
     
-    describe("get stored updates") {
-      func getStoredUpdatesInTestDB() -> [UUID] {
-        var storedUpdateIds: [UUID] = []
-        let semaphore = DispatchSemaphore(value: 0)
-        AppLauncherWithDatabase.storedUpdateIds(inDatabase: db) { error, storedUpdateIdsInner in
-          storedUpdateIds = storedUpdateIdsInner!
-          semaphore.signal()
-        }
-        _ = semaphore.wait(timeout: DispatchTime.now() + .seconds(5))
-        return storedUpdateIds
-      }
-      
-      it("works in empty db") {
-        let storedUpdateIds = getStoredUpdatesInTestDB()
-        expect(storedUpdateIds.count) == 0
-      }
-      
-      it("gets correct ids") {
-        let testUpdate = AppLauncherWithDatabaseMock.testUpdate
-        let yesterday = Date(timeIntervalSinceNow: 24 * 60 * 60 * -1)
-        testUpdate.lastAccessed = yesterday
-        db.databaseQueue.sync {
-          try! db.addUpdate(testUpdate)
-        }
-        
-        let storedUpdateIds = getStoredUpdatesInTestDB()
-        expect(storedUpdateIds.count) == 1
-        expect(storedUpdateIds.first!.uuidString) == testUpdate.updateId.uuidString
-      }
-    }
-    
     describe("launch update") {
       it("works") {
         let testUpdate = AppLauncherWithDatabaseMock.testUpdate
@@ -111,7 +83,11 @@ class AppLauncherWithDatabaseSpec : ExpoSpec {
           try! db.addNewAssets([testAsset], toUpdateWithId: testUpdate.updateId)
         }
         
-        let config = UpdatesConfig.config(fromDictionary: [UpdatesConfig.EXUpdatesConfigScopeKeyKey:"dummyScope"])
+        let config = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "dummyScope",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+        ])
         let launcher = AppLauncherWithDatabaseMock(
           config: config,
           database: db,
diff --git a/node_modules/expo-updates/ios/Tests/DatabaseIntegrityCheckSpec.swift b/node_modules/expo-updates/ios/Tests/DatabaseIntegrityCheckSpec.swift
index 7d32a51..a40b094 100644
--- a/node_modules/expo-updates/ios/Tests/DatabaseIntegrityCheckSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/DatabaseIntegrityCheckSpec.swift
@@ -49,7 +49,8 @@ class UpdatesDatabaseIntegrityCheckSpec : ExpoSpec {
         
         let scopeKey = "testScopeKey"
         let runtimeVersion = "1.0"
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
           UpdatesConfig.EXUpdatesConfigScopeKeyKey: scopeKey,
           UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: runtimeVersion
         ])
@@ -107,7 +108,8 @@ class UpdatesDatabaseIntegrityCheckSpec : ExpoSpec {
         
         let scopeKey = "testScopeKey"
         let runtimeVersion = "1.0"
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
           UpdatesConfig.EXUpdatesConfigScopeKeyKey: scopeKey,
           UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: runtimeVersion
         ])
diff --git a/node_modules/expo-updates/ios/Tests/ErrorRecoverySpec.swift b/node_modules/expo-updates/ios/Tests/ErrorRecoverySpec.swift
index 348e58b..7072582 100644
--- a/node_modules/expo-updates/ios/Tests/ErrorRecoverySpec.swift
+++ b/node_modules/expo-updates/ios/Tests/ErrorRecoverySpec.swift
@@ -80,14 +80,17 @@ class ErrorRecoverySpec : ExpoSpec {
   override func spec() {
     func setUp() -> (DispatchQueue, ErrorRecovery) {
       let testQueue = DispatchQueue(label: "expo.errorRecoveryTestQueue")
-      return (testQueue, ErrorRecovery(errorRecoveryQueue: testQueue, diskWriteQueue: testQueue, remoteLoadTimeout: 500))
+      return (testQueue, ErrorRecovery(errorRecoveryQueue: testQueue, remoteLoadTimeout: 500))
     }
     
     describe("handleError") {
       it("NewWorkingUpdateAlreadyLoaded") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .NewUpdateLoaded
@@ -106,7 +109,10 @@ class ErrorRecoverySpec : ExpoSpec {
       it("NewWorkingUpdateAlreadyLoaded_RCTContentDidAppear") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .NewUpdateLoaded
@@ -129,7 +135,10 @@ class ErrorRecoverySpec : ExpoSpec {
       it("NewUpdateLoaded_RelaunchFails") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (NSError(domain: "huh", code: 123), false)
         )
         mockDelegate.remoteLoadStatus = .NewUpdateLoaded
@@ -150,7 +159,10 @@ class ErrorRecoverySpec : ExpoSpec {
       xit("NewWorkingUpdateLoading") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .Loading
@@ -174,7 +186,10 @@ class ErrorRecoverySpec : ExpoSpec {
         let (testQueue, errorRecovery) = setUp()
         // should wait a short window for new update to load, then crash
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .Loading
@@ -204,7 +219,10 @@ class ErrorRecoverySpec : ExpoSpec {
       it("NewBrokenUpdateLoaded_WorkingUpdateCached") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .NewUpdateLoaded
@@ -231,7 +249,10 @@ class ErrorRecoverySpec : ExpoSpec {
         let (testQueue, errorRecovery) = setUp()
         // if an update has already been launched successfully, we don't want to fall back to an older update
         
-        let config = UpdatesConfig.config(fromDictionary: [:])
+        let config = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+        ])
         let database = UpdatesDatabase()
         let mockDelegate = MockErrorRecoveryDelegate(
           config: config,
@@ -278,7 +299,10 @@ class ErrorRecoverySpec : ExpoSpec {
       xit("RemoteLoadTimesOut") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .Loading
@@ -300,7 +324,7 @@ class ErrorRecoverySpec : ExpoSpec {
       xit("RemoteLoadTimesOut_UpdateAlreadyLaunchedSuccessfully") {
         let (testQueue, errorRecovery) = setUp()
         // if an update has already been launched successfully, we don't want to fall back to an older update
-        let config = UpdatesConfig.config(fromDictionary: [:])
+        let config = try! UpdatesConfig.config(fromDictionary: [:])
         let database = UpdatesDatabase()
         let mockDelegate = MockErrorRecoveryDelegate(
           config: config,
@@ -343,7 +367,10 @@ class ErrorRecoverySpec : ExpoSpec {
       xit("RemoteLoadTimesOut_RCTContentDidAppear") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .Loading
@@ -370,7 +397,10 @@ class ErrorRecoverySpec : ExpoSpec {
       it("NoRemoteUpdate") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .Idle
@@ -393,7 +423,10 @@ class ErrorRecoverySpec : ExpoSpec {
       it("NoRemoteUpdate_RCTContentDidAppear") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .Idle
@@ -418,8 +451,10 @@ class ErrorRecoverySpec : ExpoSpec {
       
       it("CheckAutomaticallyNever") {
         let (testQueue, errorRecovery) = setUp()
-        let config = UpdatesConfig.config(fromDictionary: [
-          UpdatesConfig.EXUpdatesConfigCheckOnLaunchKey: UpdatesConfig.EXUpdatesConfigCheckOnLaunchValueNever
+        let config = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigCheckOnLaunchKey: UpdatesConfig.EXUpdatesConfigCheckOnLaunchValueNever,
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let mockDelegate = MockErrorRecoveryDelegate(
           config: config,
@@ -438,8 +473,10 @@ class ErrorRecoverySpec : ExpoSpec {
       
       it("CheckAutomaticallyNever_RCTContentDidAppear") {
         let (testQueue, errorRecovery) = setUp()
-        let config = UpdatesConfig.config(fromDictionary: [
-          UpdatesConfig.EXUpdatesConfigCheckOnLaunchKey: UpdatesConfig.EXUpdatesConfigCheckOnLaunchValueNever
+        let config = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigCheckOnLaunchKey: UpdatesConfig.EXUpdatesConfigCheckOnLaunchValueNever,
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let mockDelegate = MockErrorRecoveryDelegate(
           config: config,
@@ -464,7 +501,10 @@ class ErrorRecoverySpec : ExpoSpec {
       it("handles two errors") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .Idle
@@ -484,7 +524,10 @@ class ErrorRecoverySpec : ExpoSpec {
       it("handles exceptions") {
         let (testQueue, errorRecovery) = setUp()
         let mockDelegate = MockErrorRecoveryDelegate(
-          config: UpdatesConfig.config(fromDictionary: [:]),
+          config: try! UpdatesConfig.config(fromDictionary: [
+            UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+            UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+          ]),
           relaunchCompletionParams: (nil, true)
         )
         mockDelegate.remoteLoadStatus = .NewUpdateLoaded
@@ -503,13 +546,14 @@ class ErrorRecoverySpec : ExpoSpec {
     
     describe("error log") {
       it("consume") {
-        let (testQueue, errorRecovery) = setUp()
+        let (testQueue, _) = setUp()
         // start with a clean slate
         _ = ErrorRecovery.consumeErrorLog()
         
         let error = NSError(domain: "TestDomain", code: 47, userInfo: [NSLocalizedDescriptionKey: "TestLocalizedDescription"])
-        errorRecovery.writeErrorOrExceptionToLog(error)
+        ErrorRecovery.writeErrorOrExceptionToLog(error, dispatchQueue: testQueue)
         testQueue.flush()
+        DispatchQueue.global().flush()
         
         let errorLog = ErrorRecovery.consumeErrorLog()
         expect(errorLog?.contains("TestDomain")) == true
@@ -518,16 +562,17 @@ class ErrorRecoverySpec : ExpoSpec {
       }
       
       it("consume multiple errors") {
-        let (testQueue, errorRecovery) = setUp()
+        let (testQueue, _) = setUp()
         // start with a clean slate
         _ = ErrorRecovery.consumeErrorLog()
         
         let error = NSError(domain: "TestDomain", code: 47, userInfo: [NSLocalizedDescriptionKey: "TestLocalizedDescription"])
-        errorRecovery.writeErrorOrExceptionToLog(error)
+        ErrorRecovery.writeErrorOrExceptionToLog(error, dispatchQueue: testQueue)
         
         let exception = NSException(name: NSExceptionName(rawValue: "TestName"), reason: "TestReason")
-        errorRecovery.writeErrorOrExceptionToLog(exception)
+        ErrorRecovery.writeErrorOrExceptionToLog(exception, dispatchQueue: testQueue)
         testQueue.flush()
+        DispatchQueue.global().flush()
         
         let errorLog = ErrorRecovery.consumeErrorLog()
         expect(errorLog?.contains("TestDomain")) == true
diff --git a/node_modules/expo-updates/ios/Tests/FileDownloaderManifestParsingSpec.swift b/node_modules/expo-updates/ios/Tests/FileDownloaderManifestParsingSpec.swift
index 16b615a..9fa4855 100644
--- a/node_modules/expo-updates/ios/Tests/FileDownloaderManifestParsingSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/FileDownloaderManifestParsingSpec.swift
@@ -18,8 +18,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
     
     describe("manifest parsing") {
       it("JSON body") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let downloader = FileDownloader(config: config)
         let contentType = "application/json"
@@ -46,8 +47,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("multipart body") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let downloader = FileDownloader(config: config)
         
@@ -87,8 +89,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("multipart body only directive") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let downloader = FileDownloader(config: config)
         
@@ -128,8 +131,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("multipart body only directive v0 compatibility mode") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
           UpdatesConfig.EXUpdatesConfigEnableExpoUpdatesProtocolV0CompatibilityModeKey: true
         ])
         let downloader = FileDownloader(config: config)
@@ -165,8 +169,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("multipart body no relevant parts") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let downloader = FileDownloader(config: config)
         
@@ -205,8 +210,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
 
       it("multipart body empty") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let downloader = FileDownloader(config: config)
 
@@ -237,8 +243,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
 
       it("nil body protocol 1") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let downloader = FileDownloader(config: config)
 
@@ -269,8 +276,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
 
       it("204 response protocol 1") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let downloader = FileDownloader(config: config)
 
@@ -299,8 +307,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
 
       it("204 response no protocol") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let downloader = FileDownloader(config: config)
 
@@ -326,8 +335,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("json body signed") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
           UpdatesConfig.EXUpdatesConfigCodeSigningCertificateKey: getTestCertificate(.test),
           UpdatesConfig.EXUpdatesConfigCodeSigningMetadataKey: [:],
         ])
@@ -361,8 +371,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("multipart body signed") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
           UpdatesConfig.EXUpdatesConfigCodeSigningCertificateKey: getTestCertificate(.test),
           UpdatesConfig.EXUpdatesConfigCodeSigningMetadataKey: [:],
         ])
@@ -409,8 +420,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("json body expects signed receives unsigned") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
           UpdatesConfig.EXUpdatesConfigCodeSigningCertificateKey: getTestCertificate(.test),
           UpdatesConfig.EXUpdatesConfigCodeSigningMetadataKey: [:],
         ])
@@ -442,8 +454,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("multipart body signed certificate particular experience") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
           UpdatesConfig.EXUpdatesConfigCodeSigningCertificateKey: getTestCertificate(.chainRoot),
           UpdatesConfig.EXUpdatesConfigCodeSigningMetadataKey: [
             "keyid": "ca-root",
@@ -491,8 +504,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("multipart body signed certificate particular experience incorrect experience in manifest") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
           UpdatesConfig.EXUpdatesConfigCodeSigningCertificateKey: getTestCertificate(.chainRoot),
           UpdatesConfig.EXUpdatesConfigCodeSigningMetadataKey: [
             "keyid": "ca-root",
@@ -536,8 +550,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("multipart body signed certificate particular experience incorrect experience in directive") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
           UpdatesConfig.EXUpdatesConfigCodeSigningCertificateKey: getTestCertificate(.chainRoot),
           UpdatesConfig.EXUpdatesConfigCodeSigningMetadataKey: [
             "keyid": "ca-root",
@@ -581,8 +596,9 @@ class FileDownloaderManifestParsingSpec : ExpoSpec {
       }
       
       it("json body signed unsigned request manifest signature optional") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
           UpdatesConfig.EXUpdatesConfigCodeSigningCertificateKey: getTestCertificate(.test),
           UpdatesConfig.EXUpdatesConfigCodeSigningMetadataKey: [:],
           UpdatesConfig.EXUpdatesConfigCodeSigningAllowUnsignedManifestsKey: true
diff --git a/node_modules/expo-updates/ios/Tests/FileDownloaderSpec.swift b/node_modules/expo-updates/ios/Tests/FileDownloaderSpec.swift
index db94729..643e230 100644
--- a/node_modules/expo-updates/ios/Tests/FileDownloaderSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/FileDownloaderSpec.swift
@@ -37,7 +37,7 @@ class FileDownloaderSpec : ExpoSpec {
     
     describe("cache control") {
       it("works for legacy manifest") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
           UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1.0",
         ])
@@ -48,7 +48,7 @@ class FileDownloaderSpec : ExpoSpec {
       }
       
       it("works for new manifest") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://u.expo.dev/00000000-0000-0000-0000-000000000000",
           UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1.0",
         ])
@@ -61,7 +61,7 @@ class FileDownloaderSpec : ExpoSpec {
     
     describe("extra headers") {
       it("works for object types") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://u.expo.dev/00000000-0000-0000-0000-000000000000",
           UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1.0",
         ])
@@ -83,7 +83,7 @@ class FileDownloaderSpec : ExpoSpec {
       }
       
       it("override order") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://u.expo.dev/00000000-0000-0000-0000-000000000000",
           UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1.0",
           UpdatesConfig.EXUpdatesConfigRequestHeadersKey: [
@@ -107,8 +107,9 @@ class FileDownloaderSpec : ExpoSpec {
     
     describe("get extra headers") {
       it("works") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         
         let launchedUpdateUUIDString = "7c1d2bd0-f88b-454d-998c-7fa92a924dbf"
@@ -142,8 +143,8 @@ class FileDownloaderSpec : ExpoSpec {
         )
         
         db.databaseQueue.sync {
-          try! db.setExtraParam(key: "hello", value: "world", withScopeKey: config.scopeKey!)
-          try! db.setExtraParam(key: "what", value: "123", withScopeKey: config.scopeKey!)
+          try! db.setExtraParam(key: "hello", value: "world", withScopeKey: config.scopeKey)
+          try! db.setExtraParam(key: "what", value: "123", withScopeKey: config.scopeKey)
 
           let extraHeaders = FileDownloader.extraHeadersForRemoteUpdateRequest(
             withDatabase: db,
@@ -159,8 +160,9 @@ class FileDownloaderSpec : ExpoSpec {
       }
       
       it("no launched or embedded update") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         
         db.databaseQueue.sync {
@@ -179,7 +181,7 @@ class FileDownloaderSpec : ExpoSpec {
     
     describe("asset extra headers") {
       it("override order") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://u.expo.dev/00000000-0000-0000-0000-000000000000",
           UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1.0",
           UpdatesConfig.EXUpdatesConfigRequestHeadersKey: [
@@ -201,7 +203,7 @@ class FileDownloaderSpec : ExpoSpec {
       }
       
       it("object types") {
-        let config = UpdatesConfig.config(fromDictionary: [
+        let config = try! UpdatesConfig.config(fromDictionary: [
           UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://u.expo.dev/00000000-0000-0000-0000-000000000000",
           UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1.0",
         ])
diff --git a/node_modules/expo-updates/ios/Tests/LegacyUpdateSpec.swift b/node_modules/expo-updates/ios/Tests/LegacyUpdateSpec.swift
index 0a5091f..f41b2fd 100644
--- a/node_modules/expo-updates/ios/Tests/LegacyUpdateSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/LegacyUpdateSpec.swift
@@ -7,10 +7,11 @@ import ExpoModulesTestCore
 import EXManifests
 
 class LegacyUpdateSpec : ExpoSpec {
-  let config = UpdatesConfig.config(fromDictionary: [
-    UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test"
+  let config = try! UpdatesConfig.config(fromDictionary: [
+    UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+    UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
   ])
-  let selfHostedConfig = UpdatesConfig.config(fromDictionary: [
+  let selfHostedConfig = try! UpdatesConfig.config(fromDictionary: [
     UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://esamelson.github.io/self-hosting-test/ios-index.json",
     UpdatesConfig.EXUpdatesConfigSDKVersionKey: "38.0.0"
   ])
@@ -21,17 +22,35 @@ class LegacyUpdateSpec : ExpoSpec {
       it("expo domain") {
         let manifest = LegacyManifest(rawManifestJSON: [:])
         let expected = URL(string: "https://classic-assets.eascdn.net/~assets/")
-        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: UpdatesConfig.config(fromDictionary: [UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test"]))) == expected
-        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: UpdatesConfig.config(fromDictionary: [UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://expo.io/@test/test"]))) == expected
-        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: UpdatesConfig.config(fromDictionary: [UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://expo.test/@test/test"]))) == expected
+        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+        ]))) == expected
+        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://expo.io/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+        ]))) == expected
+        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://expo.test/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+        ]))) == expected
       }
 
       it("expo subdomain") {
         let manifest = LegacyManifest(rawManifestJSON: [:])
         let expected = URL(string: "https://classic-assets.eascdn.net/~assets/")
-        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: UpdatesConfig.config(fromDictionary: [UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://staging.exp.host/@test/test"]))) == expected
-        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: UpdatesConfig.config(fromDictionary: [UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://staging.expo.io/@test/test"]))) == expected
-        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: UpdatesConfig.config(fromDictionary: [UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://staging.expo.test/@test/test"]))) == expected
+        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://staging.exp.host/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+        ]))) == expected
+        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://staging.expo.io/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+        ]))) == expected
+        expect(LegacyUpdate.bundledAssetBaseUrl(withManifest: manifest, config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://staging.expo.test/@test/test",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
+        ]))) == expected
       }
 
       it("AssetUrlOverride AbsoluteUrl") {
diff --git a/node_modules/expo-updates/ios/Tests/NewUpdateSpec.swift b/node_modules/expo-updates/ios/Tests/NewUpdateSpec.swift
index cd4d497..3f8f964 100644
--- a/node_modules/expo-updates/ios/Tests/NewUpdateSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/NewUpdateSpec.swift
@@ -7,8 +7,9 @@ import ExpoModulesTestCore
 import EXManifests
 
 class NewUpdateSpec : ExpoSpec {
-  let config = UpdatesConfig.config(fromDictionary: [
-    UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test"
+  let config = try! UpdatesConfig.config(fromDictionary: [
+    UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+    UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
   ])
   let database = UpdatesDatabase()
 
diff --git a/node_modules/expo-updates/ios/Tests/ReaperSelectionPolicyDevelopmentClientSpec.swift b/node_modules/expo-updates/ios/Tests/ReaperSelectionPolicyDevelopmentClientSpec.swift
index 9c9a981..ff16259 100644
--- a/node_modules/expo-updates/ios/Tests/ReaperSelectionPolicyDevelopmentClientSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/ReaperSelectionPolicyDevelopmentClientSpec.swift
@@ -22,8 +22,10 @@ class ReaperSelectionPolicyDevelopmentClientSpec : ExpoSpec {
       // test updates with different scopes to ensure this policy ignores scopes
       update1 = Update(
         manifest: ManifestFactory.manifest(forManifestJSON: [:]),
-        config: UpdatesConfig.config(fromDictionary: [
-          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope1"
+        config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope1",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ]),
         database: database,
         updateId: UUID(),
@@ -37,8 +39,10 @@ class ReaperSelectionPolicyDevelopmentClientSpec : ExpoSpec {
       )
       update2 = Update(
         manifest: ManifestFactory.manifest(forManifestJSON: [:]),
-        config: UpdatesConfig.config(fromDictionary: [
-          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope2"
+        config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope2",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ]),
         database: database,
         updateId: UUID(),
@@ -52,8 +56,10 @@ class ReaperSelectionPolicyDevelopmentClientSpec : ExpoSpec {
       )
       update3 = Update(
         manifest: ManifestFactory.manifest(forManifestJSON: [:]),
-        config: UpdatesConfig.config(fromDictionary: [
-          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope3"
+        config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope3",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ]),
         database: database,
         updateId: UUID(),
@@ -67,8 +73,10 @@ class ReaperSelectionPolicyDevelopmentClientSpec : ExpoSpec {
       )
       update4 = Update(
         manifest: ManifestFactory.manifest(forManifestJSON: [:]),
-        config: UpdatesConfig.config(fromDictionary: [
-          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope4"
+        config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope4",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ]),
         database: database,
         updateId: UUID(),
@@ -82,8 +90,10 @@ class ReaperSelectionPolicyDevelopmentClientSpec : ExpoSpec {
       )
       update5 = Update(
         manifest: ManifestFactory.manifest(forManifestJSON: [:]),
-        config: UpdatesConfig.config(fromDictionary: [
-          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope5"
+        config: try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope5",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ]),
         database: database,
         updateId: UUID(),
diff --git a/node_modules/expo-updates/ios/Tests/ReaperSelectionPolicyFilterAwareSpec.swift b/node_modules/expo-updates/ios/Tests/ReaperSelectionPolicyFilterAwareSpec.swift
index dd4c369..b2487ab 100644
--- a/node_modules/expo-updates/ios/Tests/ReaperSelectionPolicyFilterAwareSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/ReaperSelectionPolicyFilterAwareSpec.swift
@@ -20,8 +20,10 @@ class ReaperSelectionPolicyFilterAwareSpec : ExpoSpec {
     beforeEach {
       let runtimeVersion = "1.0"
       let scopeKey = "dummyScope"
-      config = UpdatesConfig.config(fromDictionary: [
-        UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope1"
+      config = try! UpdatesConfig.config(fromDictionary: [
+        UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+        UpdatesConfig.EXUpdatesConfigScopeKeyKey: "scope1",
+        UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
       ])
       database = UpdatesDatabase()
       update1 = Update(
@@ -119,8 +121,10 @@ class ReaperSelectionPolicyFilterAwareSpec : ExpoSpec {
       }
       
       it("updates to delete - different scope key") {
-        let configDifferentScope = UpdatesConfig.config(fromDictionary: [
-          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "differentScopeKey"
+        let configDifferentScope = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
+          UpdatesConfig.EXUpdatesConfigScopeKeyKey: "differentScopeKey",
+          UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
         ])
         let update4DifferentScope = Update(
           manifest: update4.manifest,
diff --git a/node_modules/expo-updates/ios/Tests/SelectionPolicyFilterAwareSpec.swift b/node_modules/expo-updates/ios/Tests/SelectionPolicyFilterAwareSpec.swift
index e34fc89..b604f02 100644
--- a/node_modules/expo-updates/ios/Tests/SelectionPolicyFilterAwareSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/SelectionPolicyFilterAwareSpec.swift
@@ -38,7 +38,8 @@ class SelectionPolicyFilterAwareSpec : ExpoSpec {
 
       let runtimeVersion = "1.0"
       let scopeKey = "dummyScope"
-      let config = UpdatesConfig.config(fromDictionary: [
+      let config = try! UpdatesConfig.config(fromDictionary: [
+        UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
         UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: runtimeVersion,
         UpdatesConfig.EXUpdatesConfigScopeKeyKey: scopeKey
       ])
diff --git a/node_modules/expo-updates/ios/Tests/UpdateSpec.swift b/node_modules/expo-updates/ios/Tests/UpdateSpec.swift
index 395bf4e..7c3e6ea 100644
--- a/node_modules/expo-updates/ios/Tests/UpdateSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/UpdateSpec.swift
@@ -7,7 +7,8 @@ import ExpoModulesTestCore
 import EXManifests
 
 class UpdateSpec : ExpoSpec {
-  let config = UpdatesConfig.config(fromDictionary: [
+  let config = try! UpdatesConfig.config(fromDictionary: [
+    UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
     UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test"
   ])
   let database = UpdatesDatabase()
@@ -92,20 +93,6 @@ class UpdateSpec : ExpoSpec {
         )).to(throwError(UpdateError.invalidExpoProtocolVersion))
       }
       
-      it("works for embedded legacy manifest") {
-        let legacyManifest = [
-          "sdkVersion": "39.0.0",
-          "releaseId": "0eef8214-4833-4089-9dff-b4138a14f196",
-          "commitTime": "2020-11-11T00:17:54.797Z",
-          "bundleUrl": "https://url.to/bundle.js"
-        ]
-        expect(Update.update(
-          withEmbeddedManifest: legacyManifest,
-          config: self.config,
-          database: self.database
-        )).notTo(beNil())
-      }
-      
       it("works for embedded bare manifest") {
         let bareManifest = [
           "id": "0eef8214-4833-4089-9dff-b4138a14f196",
diff --git a/node_modules/expo-updates/ios/Tests/UpdatesBuildDataSpec.swift b/node_modules/expo-updates/ios/Tests/UpdatesBuildDataSpec.swift
index 574b1eb..59f9d80 100644
--- a/node_modules/expo-updates/ios/Tests/UpdatesBuildDataSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/UpdatesBuildDataSpec.swift
@@ -47,30 +47,34 @@ class UpdatesBuildDataSpec : ExpoSpec {
       configChannelTestDictionary = [
         UpdatesConfig.EXUpdatesConfigScopeKeyKey: scopeKey,
         UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
-        UpdatesConfig.EXUpdatesConfigRequestHeadersKey: ["expo-channel-name":"test"]
+        UpdatesConfig.EXUpdatesConfigRequestHeadersKey: ["expo-channel-name":"test"],
+        UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
       ]
-      configChannelTest = UpdatesConfig.config(fromDictionary: configChannelTestDictionary)
+      configChannelTest = try! UpdatesConfig.config(fromDictionary: configChannelTestDictionary)
       
       configChannelTestTwoDictionary = [
         UpdatesConfig.EXUpdatesConfigScopeKeyKey: scopeKey,
         UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
-        UpdatesConfig.EXUpdatesConfigRequestHeadersKey: ["expo-channel-name":"testTwo"]
+        UpdatesConfig.EXUpdatesConfigRequestHeadersKey: ["expo-channel-name":"testTwo"],
+        UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
       ]
-      configChannelTestTwo = UpdatesConfig.config(fromDictionary: configChannelTestTwoDictionary)
+      configChannelTestTwo = try! UpdatesConfig.config(fromDictionary: configChannelTestTwoDictionary)
 
       configReleaseChannelTestDictionary = [
         UpdatesConfig.EXUpdatesConfigScopeKeyKey: scopeKey,
         UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
         UpdatesConfig.EXUpdatesConfigReleaseChannelKey: "test",
+        UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
       ]
-      configReleaseChannelTest = UpdatesConfig.config(fromDictionary: configReleaseChannelTestDictionary)
+      configReleaseChannelTest = try! UpdatesConfig.config(fromDictionary: configReleaseChannelTestDictionary)
       
       configReleaseChannelTestTwoDictionary = [
         UpdatesConfig.EXUpdatesConfigScopeKeyKey: scopeKey,
         UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
         UpdatesConfig.EXUpdatesConfigReleaseChannelKey: "testTwo",
+        UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
       ]
-      configReleaseChannelTestTwo = UpdatesConfig.config(fromDictionary: configReleaseChannelTestTwoDictionary)
+      configReleaseChannelTestTwo = try! UpdatesConfig.config(fromDictionary: configReleaseChannelTestTwoDictionary)
       
       // start every test with an update
       db.databaseQueue.sync {
@@ -126,7 +130,7 @@ class UpdatesBuildDataSpec : ExpoSpec {
       it("no updates are cleared and build data is not set when build data is consistent with channel") {
         db.databaseQueue.sync {
           expect(try! db.allUpdates(withConfig: configChannelTest).count) == 1
-          try! db.setStaticBuildData(UpdatesBuildData.getBuildDataFromConfig(configChannelTest), withScopeKey: configChannelTest.scopeKey!)
+          try! db.setStaticBuildData(UpdatesBuildData.getBuildDataFromConfig(configChannelTest), withScopeKey: configChannelTest.scopeKey)
         }
         
         UpdatesBuildData.ensureBuildDataIsConsistentAsync(database: db, config: configChannelTest)
@@ -143,7 +147,7 @@ class UpdatesBuildDataSpec : ExpoSpec {
       it("works when build data is consistent with releaseChannel") {
         db.databaseQueue.sync {
           expect(try! db.allUpdates(withConfig: configReleaseChannelTest).count) == 1
-          try! db.setStaticBuildData(UpdatesBuildData.getBuildDataFromConfig(configReleaseChannelTest), withScopeKey: configReleaseChannelTest.scopeKey!)
+          try! db.setStaticBuildData(UpdatesBuildData.getBuildDataFromConfig(configReleaseChannelTest), withScopeKey: configReleaseChannelTest.scopeKey)
         }
         
         UpdatesBuildData.ensureBuildDataIsConsistentAsync(database: db, config: configReleaseChannelTest)
@@ -160,7 +164,7 @@ class UpdatesBuildDataSpec : ExpoSpec {
       it("updates are cleared and build data is set when build data is inconsistent with channel") {
         db.databaseQueue.sync {
           expect(try! db.allUpdates(withConfig: configChannelTest).count) == 1
-          try! db.setStaticBuildData(UpdatesBuildData.getBuildDataFromConfig(configChannelTest), withScopeKey: configChannelTest.scopeKey!)
+          try! db.setStaticBuildData(UpdatesBuildData.getBuildDataFromConfig(configChannelTest), withScopeKey: configChannelTest.scopeKey)
         }
         
         UpdatesBuildData.ensureBuildDataIsConsistentAsync(database: db, config: configChannelTestTwo)
@@ -177,7 +181,7 @@ class UpdatesBuildDataSpec : ExpoSpec {
       it("works build data is inconsistent release channel") {
         db.databaseQueue.sync {
           expect(try! db.allUpdates(withConfig: configReleaseChannelTest).count) == 1
-          try! db.setStaticBuildData(UpdatesBuildData.getBuildDataFromConfig(configReleaseChannelTest), withScopeKey: configChannelTest.scopeKey!)
+          try! db.setStaticBuildData(UpdatesBuildData.getBuildDataFromConfig(configReleaseChannelTest), withScopeKey: configChannelTest.scopeKey)
         }
         
         UpdatesBuildData.ensureBuildDataIsConsistentAsync(database: db, config: configReleaseChannelTestTwo)
diff --git a/node_modules/expo-updates/ios/Tests/UpdatesConfigSpec.swift b/node_modules/expo-updates/ios/Tests/UpdatesConfigSpec.swift
index b68e04d..a202589 100644
--- a/node_modules/expo-updates/ios/Tests/UpdatesConfigSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/UpdatesConfigSpec.swift
@@ -14,11 +14,13 @@ class UpdatesConfigSpec : ExpoSpec {
       it("instantiates") {
         let bundle = Bundle(for: UpdatesConfigSpecForBundle.self)
         let configPlistPath = bundle.path(forResource: "TestConfig", ofType: "plist")!
-        let config = try UpdatesConfig.configWithExpoPlist(configPlistPath: configPlistPath, mergingOtherDictionary: nil)
-        expect(config.isEnabled) == true
+        guard let configNSDictionary = NSDictionary(contentsOfFile: configPlistPath) as? [String: Any] else {
+          throw UpdatesConfigError.ExpoUpdatesConfigPlistError
+        }
+        let config = try! UpdatesConfig.config(fromDictionary: configNSDictionary)
         expect(config.expectsSignedManifest) == true
         expect(config.scopeKey) == "blah"
-        expect(config.updateUrl?.absoluteString) == "http://example.com"
+        expect(config.updateUrl.absoluteString) == "http://example.com"
         expect(config.requestHeaders) == ["Hello": "World"]
         expect(config.releaseChannel) == "test"
         expect(config.launchWaitMs) == 2
@@ -26,7 +28,7 @@ class UpdatesConfigSpec : ExpoSpec {
         expect(config.codeSigningConfiguration).toNot(beNil())
         expect(config.enableExpoUpdatesProtocolV0CompatibilityMode) == false
         expect(config.sdkVersion) == "10.0.0"
-        expect(config.runtimeVersion) == "fake-version-1"
+        expect(config.runtimeVersionRaw) == "fake-version-1"
         expect(config.hasEmbeddedUpdate) == true
       }
 
@@ -43,11 +45,16 @@ class UpdatesConfigSpec : ExpoSpec {
           UpdatesConfig.EXUpdatesConfigRequestHeadersKey: ["Foo": "Bar"],
         ]
 
-        let config = try UpdatesConfig.configWithExpoPlist(configPlistPath: configPlistPath, mergingOtherDictionary: otherDictionary)
-        expect(config.isEnabled) == false
+        guard let configNSDictionary = NSDictionary(contentsOfFile: configPlistPath) as? [String: Any] else {
+          throw UpdatesConfigError.ExpoUpdatesConfigPlistError
+        }
+
+        var dictionary: [String: Any] = configNSDictionary.merging(otherDictionary, uniquingKeysWith: { _, new in new })
+
+        let config = try! UpdatesConfig.config(fromDictionary: dictionary)
         expect(config.expectsSignedManifest) == false
         expect(config.scopeKey) == "overridden"
-        expect(config.updateUrl?.absoluteString) == "http://google.com"
+        expect(config.updateUrl.absoluteString) == "http://google.com"
         expect(config.requestHeaders) == ["Foo": "Bar"]
         expect(config.releaseChannel) == "test"
         expect(config.launchWaitMs) == 2
@@ -55,35 +62,38 @@ class UpdatesConfigSpec : ExpoSpec {
         expect(config.codeSigningConfiguration).toNot(beNil())
         expect(config.enableExpoUpdatesProtocolV0CompatibilityMode) == false
         expect(config.sdkVersion) == "10.0.0"
-        expect(config.runtimeVersion) == "fake-version-1"
+        expect(config.runtimeVersionRaw) == "fake-version-1"
         expect(config.hasEmbeddedUpdate) == true
       }
     }
 
     describe("getRuntimeVersion") {
       it("returns sdk version when only sdk version") {
-        let sdkOnlyConfig = UpdatesConfig.config(fromDictionary: [
+        let sdkOnlyConfig = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
           "EXUpdatesScopeKey": "test",
           "EXUpdatesSDKVersion": "38.0.0"
         ])
-        expect(UpdatesUtils.getRuntimeVersion(withConfig: sdkOnlyConfig)) == "38.0.0"
+        expect(sdkOnlyConfig.runtimeVersionRealized) == "38.0.0"
       }
 
       it("returns runtime version when only runtime version") {
-        let runtimeOnlyConfig = UpdatesConfig.config(fromDictionary: [
+        let runtimeOnlyConfig = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
           "EXUpdatesScopeKey": "test",
           "EXUpdatesRuntimeVersion": "1.0"
         ])
-        expect(UpdatesUtils.getRuntimeVersion(withConfig: runtimeOnlyConfig)) == "1.0"
+        expect(runtimeOnlyConfig.runtimeVersionRealized) == "1.0"
       }
 
       it("returns runtime version when both sdk and runtime version") {
-        let bothConfig = UpdatesConfig.config(fromDictionary: [
+        let bothConfig = try! UpdatesConfig.config(fromDictionary: [
+          UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://example.com",
           "EXUpdatesScopeKey": "test",
           "EXUpdatesSDKVersion": "38.0.0",
           "EXUpdatesRuntimeVersion": "1.0"
         ])
-        expect(UpdatesUtils.getRuntimeVersion(withConfig: bothConfig)) == "1.0"
+        expect(bothConfig.runtimeVersionRealized) == "1.0"
       }
     }
 
diff --git a/node_modules/expo-updates/ios/Tests/UpdatesDatabaseSpec.swift b/node_modules/expo-updates/ios/Tests/UpdatesDatabaseSpec.swift
index c49e092..c60694d 100644
--- a/node_modules/expo-updates/ios/Tests/UpdatesDatabaseSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/UpdatesDatabaseSpec.swift
@@ -34,8 +34,9 @@ class UpdatesDatabaseSpec : ExpoSpec {
         "launchAsset": ["url": "https://url.to/bundle.js", "contentType": "application/javascript"]
       ])
 
-      config = UpdatesConfig.config(fromDictionary: [
-        UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test"
+      config = try! UpdatesConfig.config(fromDictionary: [
+        UpdatesConfig.EXUpdatesConfigUpdateUrlKey: "https://exp.host/@test/test",
+        UpdatesConfig.EXUpdatesConfigRuntimeVersionKey: "1",
       ])
     }
     
diff --git a/node_modules/expo-updates/ios/Tests/UpdatesStateMachineSpec.swift b/node_modules/expo-updates/ios/Tests/UpdatesStateMachineSpec.swift
index 7357921..1e3eea3 100644
--- a/node_modules/expo-updates/ios/Tests/UpdatesStateMachineSpec.swift
+++ b/node_modules/expo-updates/ios/Tests/UpdatesStateMachineSpec.swift
@@ -22,13 +22,15 @@ class UpdatesStateMachineSpec: ExpoSpec {
     describe("default state") {
       it("instantiates") {
         let testStateChangeDelegate = TestStateChangeDelegate()
-        let machine = UpdatesStateMachine(changeEventDelegate: testStateChangeDelegate)
+        let machine = UpdatesStateMachine()
+        machine.changeEventDelegate = testStateChangeDelegate
         expect(machine.state) == .idle
       }
 
       it("should handle check and checkCompleteAvailable") {
         let testStateChangeDelegate = TestStateChangeDelegate()
-        let machine = UpdatesStateMachine(changeEventDelegate: testStateChangeDelegate)
+        let machine = UpdatesStateMachine()
+        machine.changeEventDelegate = testStateChangeDelegate
 
         machine.processEvent(UpdatesStateEventCheck())
         expect(machine.state) == .checking
@@ -50,7 +52,8 @@ class UpdatesStateMachineSpec: ExpoSpec {
 
       it("should handle check and checkCompleteUnavailable") {
         let testStateChangeDelegate = TestStateChangeDelegate()
-        let machine = UpdatesStateMachine(changeEventDelegate: testStateChangeDelegate)
+        let machine = UpdatesStateMachine()
+        machine.changeEventDelegate = testStateChangeDelegate
 
         machine.processEvent(UpdatesStateEventCheck())
         expect(machine.state) == .checking
@@ -66,7 +69,8 @@ class UpdatesStateMachineSpec: ExpoSpec {
 
       it("should handle download and downloadComplete") {
         let testStateChangeDelegate = TestStateChangeDelegate()
-        let machine = UpdatesStateMachine(changeEventDelegate: testStateChangeDelegate)
+        let machine = UpdatesStateMachine()
+        machine.changeEventDelegate = testStateChangeDelegate
 
         machine.processEvent(UpdatesStateEventDownload())
         expect(machine.state) == .downloading
@@ -86,7 +90,8 @@ class UpdatesStateMachineSpec: ExpoSpec {
 
       it("should handle rollback") {
         let testStateChangeDelegate = TestStateChangeDelegate()
-        let machine = UpdatesStateMachine(changeEventDelegate: testStateChangeDelegate)
+        let machine = UpdatesStateMachine()
+        machine.changeEventDelegate = testStateChangeDelegate
         let commitTime = Date()
         machine.processEvent(UpdatesStateEventCheck())
         expect(machine.state) == .checking
@@ -103,7 +108,8 @@ class UpdatesStateMachineSpec: ExpoSpec {
 
       it("invalid transitions are handled as expected") {
         let testStateChangeDelegate = TestStateChangeDelegate()
-        let machine = UpdatesStateMachine(changeEventDelegate: testStateChangeDelegate)
+        let machine = UpdatesStateMachine()
+        machine.changeEventDelegate = testStateChangeDelegate
 
         machine.processEvent(UpdatesStateEventCheck())
         expect(machine.state) == .checking
